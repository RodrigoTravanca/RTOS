<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>RT OS — Simulator</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
html,body{height:100%;overflow:hidden;font-family:"Inter","Segoe UI",system-ui,Roboto,Arial;background:#0b0b0d;color:#fff;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;overscroll-behavior:none}
body{width:100%;height:100%}
:root{--bg:#0d0f11;--panel:#121416;--muted:#bfc3c6;--accent:#ffffff;--neon:rgba(255,255,255,0.95);--glass:rgba(255,255,255,0.03);--radius:18px}
.white-corners{border:1px solid rgba(255,255,255,0.95);border-radius:var(--radius)}
#desktop{height:100vh;width:100vw;position:relative;overflow:hidden;background:radial-gradient(1200px 600px at 10% 20%,rgba(255,255,255,0.02),transparent 6%),linear-gradient(180deg,#0e1012,#141517)}
.wallpaper{position:absolute;inset:0;background-size:cover;background-position:center;z-index:0;transition:filter .3s}
.desktop-inner{position:relative;z-index:auto;height:100%;display:flex;flex-direction:column}
.desktop-icons-grid{padding:28px;display:flex;flex-direction:column;flex-wrap:wrap;align-content:flex-start;gap:14px;height:calc(100vh - 76px);overflow:visible}
.icon{width:140px;flex:0 0 78px;user-select:none;display:flex;gap:12px;align-items:center;cursor:pointer;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0));padding:10px;border-radius:var(--radius);transition:transform .14s,box-shadow .14s}
.icon:hover{transform:translateY(-6px);box-shadow:0 12px 30px rgba(0,0,0,0.6)}
.icon .img{width:56px;height:56px;display:flex;align-items:center;justify-content:center;border-radius:12px;font-weight:800;color:var(--accent);font-size:18px;background:transparent;border:1px solid rgba(255,255,255,0.06)}
/* Desktop file shortcuts (e.g., notes) label: clip with ellipsis so long names don't overflow */
#desktopIcons .icon[data-file-id] label{display:block;max-width:62%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
 .icon label{font-size:13px;color:var(--accent);font-weight:700}

/* Enhanced hover selection animation (no click required) */
@keyframes hoverPulse{from{box-shadow:inset 0 0 0 0 rgba(255,255,255,0.18);opacity:1}to{box-shadow:inset 0 0 0 14px rgba(255,255,255,0);opacity:0}}
.icon{position:relative}
.icon::after{content:"";position:absolute;inset:0;border-radius:var(--radius);pointer-events:none;opacity:0}
.icon:hover{transform:translateY(-8px) scale(1.02)}
.icon:hover::after{animation:hoverPulse 580ms ease-out 1}
.icon .img{transition:transform .18s}
.icon:hover .img{transform:translateY(-2px) scale(1.06)}
.icon label{transition:color .18s,transform .18s}
.icon:hover label{transform:translateY(-1px);color:#ffffff}
.taskbar{position:fixed;left:0;right:0;bottom:0;height:64px;border-radius:18px;display:flex;align-items:center;padding:10px 18px;gap:12px;background:rgba(255,255,255,0.02);z-index:90000;box-shadow:0 10px 40px rgba(0,0,0,0.6);backdrop-filter:blur(6px);box-sizing:border-box;transition:width .28s ease,max-width .28s ease,padding .28s ease}
/* Dock wrapper that physically slides the bar */
.dock-wrap{ position:fixed; left:0; right:0; bottom:0; z-index:90000; display:flex; justify-content:center; pointer-events:none; }
.dock-wrap > .taskbar{ pointer-events:auto; position:static; left:auto; right:auto; bottom:auto; z-index:auto; }
.dock-wrap.autohide{ will-change: transform; transition: transform .36s cubic-bezier(.22,.85,.25,1); }
.dock-wrap.autohide.hidden{ transform: translateY(140%); }
/* Search button (visible in centered mode) */
.taskbar .searchbtn{display:none;align-items:center;justify-content:center;width:36px;height:36px;border-radius:10px;border:1px solid rgba(255,255,255,0.08);background:linear-gradient(180deg,rgba(255,255,255,0.07),rgba(255,255,255,0.02));color:#ffffff;cursor:pointer}
.taskbar .searchbtn:hover{box-shadow:inset 0 0 0 1px rgba(255,255,255,0.55)}
.taskbar.centered .searchbtn{display:inline-flex}
.taskbar:not(.centered) .searchbtn{display:none}
/* Centered dock style (optional via personalization) */
.taskbar.centered{transform:none !important;display:inline-flex;width:max-content !important;min-width:360px;max-width:calc(100vw - 24px);padding-left:14px;padding-right:14px;border-radius:22px;transition:transform .42s cubic-bezier(.22,.85,.25,1);will-change:transform;background:rgba(24,26,30,0.88) !important;backdrop-filter:none !important;-webkit-backdrop-filter:none !important}
.dock-wrap.autohide{bottom:10px;}
/* hidden state handled by .dock-wrap.hidden */
.taskbar.centered .task-mid{flex:0 1 auto;overflow-x:auto;min-width:260px;white-space:nowrap}

/* Keep taskbar invisible before boot completes to avoid clashing with BIOS/boot UI */
.taskbar.preboot-hidden{opacity:0; pointer-events:none; transform:translateY(30px);}
.taskbar.centered #taskRight,.taskbar.centered .task-right{display:flex !important;flex:0 0 auto;align-items:center;gap:6px}
.taskbar.centered #taskLeft,.taskbar.centered .task-left{flex:0 0 auto}
.taskbar.centered .task-mid::before,
.taskbar.centered .task-mid::after{content:"";display:block;flex:0 0 6px}
/* Ensure non-centered dock sits fully at bottom */
.taskbar:not(.centered){bottom:0}

/* Dock slide animations */
@keyframes dockIn { from { transform: translate3d(-50%, calc(100% + 18px), 0); } to { transform: translate3d(-50%, 0, 0); } }
@keyframes dockOut { from { transform: translate3d(-50%, 0, 0); } to { transform: translate3d(-50%, calc(100% + 18px), 0); } }
.taskbar.centered.autohide.revealing { animation: dockIn 0.36s cubic-bezier(.22,.85,.25,1) forwards; }
.taskbar.centered.autohide.hiding { animation: dockOut 0.32s cubic-bezier(.22,.85,.25,1) forwards; }
/* Compact search in centered mode: fully collapsed until expanded */
.taskbar.centered #taskbarSearch{flex:0 1 auto;width:0;min-width:0;padding-inline:0;opacity:0;transition:width .26s ease, opacity .16s ease, padding .26s ease}
.taskbar.centered #taskbarSearch.expanded,
.taskbar.centered #taskbarSearch:focus{width:220px;min-width:160px;padding-inline:10px;opacity:1}
/* In full mode, show input normally and hide the button */
.taskbar:not(.centered) #taskbarSearch{flex:0 1 280px;width:280px;min-width:200px;padding-inline:10px;opacity:1}
.taskbar.centered .task-mid > *{margin-left:1px;margin-right:1px;transition:transform .18s ease}
.taskbar.centered .task-mid > *:active{transform:scale(.96)}
@keyframes dockEnter{from{opacity:.85}to{opacity:1}}
.taskbar.style-switch{animation:dockEnter 160ms ease-out 1}
.taskbar.centered.style-switch{animation:dockEnter 160ms ease-out 1}
.taskbar.centered .task-mid.style-switch{animation:dockEnter 160ms ease-out 1}
/* Slide-in animation for child elements (no layout teleport, no fade-out) */
@keyframes dockSlide{0%{opacity:1;transform:translateY(6px) scale(0.992)}100%{opacity:1;transform:none}}
.taskbar.centered.dock-anim .start-btn,
.taskbar.centered.dock-anim #taskbarSearch,
.taskbar.centered.dock-anim .task-right > *,
.taskbar.centered.dock-anim .task-mid > *{animation:dockSlide 340ms cubic-bezier(.22,.85,.25,1) both}
.taskbar.centered.dock-anim .task-mid > *{animation-delay:calc(var(--i, 0) * 36ms)}
/* Ensure indicators visible even if globally hidden elsewhere */
.taskbar #wifiIndicator,.taskbar #volumeIndicator,.taskbar #timeDisplay{display:inline-flex !important}
@media (max-width:880px){.taskbar.centered{left:0;right:0;transform:none;width:auto}}
.start-btn{width:48px;height:44px;border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:15px;cursor:pointer;border:1px solid rgba(255,255,255,0.08);background:linear-gradient(180deg,rgba(255,255,255,0.07),rgba(255,255,255,0.02));color:var(--accent);user-select:none;-webkit-user-select:none;-ms-user-select:none}
.start-btn{transition:box-shadow .16s ease, border-color .16s ease}
.start-btn.hovered:not(.active){box-shadow:inset 0 0 0 1px rgba(255,255,255,0.55)}
.start-btn.active{box-shadow:inset 0 0 0 2px rgba(255,255,255,0.98)}
@keyframes startBorderPop{0%{box-shadow:inset 0 0 0 0 rgba(255,255,255,0.98)}70%{box-shadow:inset 0 0 0 3px rgba(255,255,255,0.98)}100%{box-shadow:inset 0 0 0 2px rgba(255,255,255,0.98)}}
.start-btn.active.pop{animation:startBorderPop 180ms cubic-bezier(.22,1.2,.24,1) 1}
.task-mid{flex:1;display:flex;align-items:center;gap:6px;overflow-x:auto;overflow-y:hidden;scrollbar-width:none;-ms-overflow-style:none}
.task-mid::-webkit-scrollbar{display:none}
#wifiIndicator,#volumeIndicator{display:inline-flex;align-items:center;justify-content:center;cursor:pointer;margin:0 6px 0 4px;outline:none;line-height:20px;height:20px;border:none;background:transparent;border-radius:0;box-shadow:none}
#wifiIndicator:hover,#volumeIndicator:hover{background:transparent}
#wifiIndicator:active,#volumeIndicator:active{transform:none}
#wifiIndicator svg,#volumeIndicator svg{display:block;width:18px;height:18px}
#timeDisplay{display:flex;align-items:center;height:20px;line-height:20px}
#volumeIndicator{display:none!important}
#startMenu{background:rgba(20,22,25,0.75)!important;backdrop-filter:blur(14px);position:fixed;bottom:100px;left:24px;width:360px;border-radius:18px;padding:22px 18px 18px;z-index:90020;display:none;box-shadow:0 20px 48px rgba(0,0,0,0.7)}
#startMenu.show{display:block;animation:pop .22s cubic-bezier(.41,2,.19,.91);}
#startMenu.hiding{display:block;animation:pop .20s cubic-bezier(.41,2,.19,.91) reverse forwards;}
@keyframes pop{from{transform:scale(.995) translateY(14px);opacity:0}to{transform:scale(1);opacity:1}}
@keyframes popOut{from{transform:scale(1) translateY(0);opacity:1}to{transform:scale(.985) translateY(18px);opacity:0}}
@keyframes winEnter{from{transform:translateY(8px) scale(0.992)}to{transform:none}}
@keyframes winOut{from{transform:translateY(0) scale(1)}to{transform:translateY(18px) scale(0.985)}}
.start-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;}
.app-tile{padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0));border:1px solid rgba(255,255,255,0.03);text-align:center;cursor:pointer;user-select:none;}
.app-tile:hover{box-shadow:0 4px 18px rgba(255,255,255,0.25)}
.start-title{margin:0 0 12px 0;text-align:center;font-weight:900;letter-spacing:.2px}
.app-tile[data-app="calc"]{font-size:14px;}
.start-menu-section{margin-top:8px}
/* Center RT text cleanly on Start button without altering original size */
#startBtn{display:flex;align-items:center;justify-content:center;line-height:1;font-weight:800;letter-spacing:.2px;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased}
.start-search{display:flex;align-items:center;gap:10px;margin-bottom:12px;padding:10px 12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0));border:1px solid rgba(255,255,255,0.06);cursor:pointer;user-select:none}
.start-search:hover{background:rgba(255,255,255,0.06)}
.start-search .mag{width:18px;height:18px;border-radius:50%;border:2px solid rgba(255,255,255,0.95);position:relative}
.start-search .mag::after{content:"";position:absolute;width:8px;height:2px;background:rgba(255,255,255,0.95);right:-6px;bottom:-2px;transform:rotate(45deg);border-radius:2px}
.start-search .label{color:#d8dbe0;font-weight:700}
.start-search .arrow{margin-left:auto;color:#fff;opacity:.9;font-weight:800}

/* Slide hint when jumping from Start to Search */
@keyframes startToSearch{from{transform:translateX(0);opacity:1}to{transform:translateX(30px);opacity:.0}}
#startMenu.to-search{animation:startToSearch .18s ease forwards}
.searchbox{width:250px;padding:11px 16px;border-radius:9px;background:rgba(24,27,31,0.82);border:1px solid rgba(255,255,255,0.04);color:#fff;font-size:16px;margin-right:14px;user-select:text;transition:border-color .16s ease, box-shadow .16s ease, background .16s ease;}
.searchbox::placeholder{color:rgba(255,255,255,0.45)}
.searchbox:focus{outline:none;border-color:rgba(255,255,255,0.95);box-shadow:0 0 0 2px rgba(255,255,255,0.18);background:rgba(24,27,31,0.82)}
#searchResults{position:fixed;left:38px;bottom:90px;min-width:300px;max-width:360px;max-height:50vh;overflow:auto;background:rgba(24,26,30,0.96);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);border-radius:18px;box-shadow:0 20px 48px rgba(0,0,0,0.6);display:none;z-index:90030;animation:pop .18s;border:1px solid rgba(255,255,255,0.95)}
.search-header{position:sticky;top:0;background:rgba(24,26,30,0.96);display:flex;align-items:center;gap:10px;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,0.05);z-index:1}
.search-header .back{width:32px;height:32px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center;cursor:pointer}
.search-header .back:hover{background:rgba(255,255,255,0.08)}
.search-header .title{font-weight:800}
.search-hint{padding:12px 16px;color:#aeb3b9}
.search-result{padding:12px 16px;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.05);user-select:none;}
.search-result:last-child{border-bottom:none;}
.search-result:hover{background:rgba(255,255,255,0.06);}
.window{background:rgba(20,22,25,0.88)!important;backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px);position:absolute;min-width:320px;min-height:160px;border-radius:var(--radius);overflow:hidden;display:flex;flex-direction:column;z-index:50;left:0;top:0;animation:pop .18s;box-shadow:0 30px 90px rgba(0,0,0,0.6);transition:transform .16s,box-shadow .16s,opacity .14s,width .12s ease,height .12s ease;resize:none;}
.window.white-corners{border:1px solid rgba(255,255,255,0.95);}
.window:not([data-maxed="1"]):active,.window:not([data-maxed="1"]).focus{transform:translateY(-6px);box-shadow:0 40px 110px rgba(0,0,0,0.8);}
.window[data-maxed="1"],
.window[data-maxed="1"].focus {
  /* Remove drop shadow to avoid visual overlap with taskbar */
  box-shadow:none;
  border-radius:var(--radius);
  background:rgba(20,22,25,0.96) !important;
}
.window.no-elevate { box-shadow:0 18px 60px rgba(0,0,0,0.55); }
.window[data-maxed="1"]:not([data-opening="1"]):not([data-bounce="1"]):not([data-closing="1"]),
.window.no-elevate:not([data-opening="1"]):not([data-bounce="1"]):not([data-closing="1"]) {
  /* Only suppress the elevate transform after opening finishes */
  transform:none !important;
}
.window.closing{animation:popOut .18s forwards;pointer-events:none;will-change:transform,opacity;transition:none !important;}
.window[data-maxed="1"] .win-body {
  padding:8px;
}
.mini{transform:translateY(4px) scale(.98);opacity:.9;}
.window.frame-switch{animation:winFrameSwitch 240ms cubic-bezier(.22,.85,.25,1) both}
@keyframes winFrameSwitch { from { opacity:1; transform: translateY(6px) scale(0.995); } to { opacity:1; transform:none; } }
.win-title{height:56px;display:flex;align-items:center;gap:10px;padding:0 14px;border-bottom:1px solid rgba(255,255,255,0.04);background:transparent;user-select:none;cursor:move;}
.win-title .controls{margin-left:auto;display:flex;gap:8px;}
.wbtn{width:38px;height:34px;display:flex;align-items:center;justify-content:center;border-radius:8px;cursor:pointer;border:1px solid rgba(255,255,255,0.03);background:rgba(32,34,40,0.16);transition:background .13s;}
.wbtn:hover{background:rgba(255,255,255,0.13);}
.win-body{flex:1;padding:8px;overflow:auto;background:transparent;}

/* Custom resize handles: 8 zones with larger hit area for smooth control */
.win-resize-handle{position:absolute;z-index:5;pointer-events:auto}
.win-resize-handle.edge{background:transparent}
.win-resize-handle.corner{background:transparent}
/* 10px thick edges, 14px corners for easier grab */
.win-h-n{top:-2px;left:12px;right:12px;height:8px;cursor:ns-resize}
.win-h-s{bottom:-2px;left:12px;right:12px;height:10px;cursor:ns-resize}
.win-h-e{top:12px;right:-2px;bottom:12px;width:8px;cursor:ew-resize}
.win-h-w{top:12px;left:-2px;bottom:12px;width:8px;cursor:ew-resize}
.win-h-ne{top:-2px;right:-2px;width:14px;height:14px;cursor:nesw-resize}
.win-h-nw{top:-2px;left:-2px;width:14px;height:14px;cursor:nwse-resize}
.win-h-se{bottom:-2px;right:-2px;width:16px;height:16px;cursor:nwse-resize}
.win-h-sw{bottom:-2px;left:-2px;width:16px;height:16px;cursor:nesw-resize}
.btn{padding:10px 16px;border-radius:10px;border:1px solid rgba(255,255,255,0.07);background:linear-gradient(180deg,rgba(255,255,255,0.037),rgba(255,255,255,0));color:#fff;font-weight:600;box-shadow:0 1px 4px rgba(0,0,0,0.13);font-size:15px;cursor:pointer;transition:background .16s,box-shadow .12s;}
.btn:hover{background:rgba(255,255,255,0.14);}
input,textarea,select{font:inherit;border-radius:8px;border:1px solid rgba(255,255,255,0.07);background:rgba(10,13,20,0.13);color:#fff;margin-bottom:4px;}
input:focus,textarea:focus{outline:2px solid var(--accent);}
.browser-loading-bar{background:var(--accent)}
@media (max-width:880px){.icons{display:none;}.window{width:96vw;height:60vh;left:2vw !important;top:8vh !important;}.taskbar{left:0;right:0;bottom:12px;}#startMenu{width:84vw;left:8px;bottom:84px;}#searchResults{left:18px;}}
::-webkit-scrollbar{height:10px;width:10px;}
::-webkit-scrollbar-thumb{background:rgba(255,255,255,0.06);border-radius:10px;}
#boot{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#0b0c0d 0%,#151617 100%);z-index:99999;transition:opacity .8s,transform .6s;}
#boot.hidden{opacity:0;pointer-events:none;transform:translateY(-20px) scale(.985);}
.boot-card{width:540px;padding:46px 36px;border-radius:var(--radius);background:rgba(255,255,255,0.02);text-align:center}
.logo{font-weight:800;font-size:42px;margin-bottom:12px;}
.boot-sub{color:var(--muted);margin-bottom:18px;font-size:14px;}
.progress-wrap{margin-top:18px;background:rgba(255,255,255,0.02);padding:12px;border-radius:12px;}
.progress-bar{height:10px;width:0%;border-radius:8px;background:linear-gradient(90deg,rgba(255,255,255,0.08),rgba(255,255,255,0.20));box-shadow:0 0 14px rgba(255,255,255,0.03)inset;transition:width 600ms cubic-bezier(.2,.9,.25,1);}
.boot-meta{margin-top:10px;font-size:13px;color:var(--muted);display:flex;justify-content:space-between;align-items:center;}
.boot-spinner{display:inline-block;width:12px;height:12px;border-radius:50%;border:2px solid rgba(255,255,255,0.06);border-top-color:var(--accent);animation:spin 1s linear infinite;margin-right:8px;}
@keyframes spin{from{transform:rotate(0)}to{transform:rotate(360deg)}}
/* Accent-driven tweaks (dark base) */
.btn:focus-visible, .btn:active{outline:none;border-color:var(--accent);box-shadow:0 0 0 2px rgba(255,255,255,0.03), 0 0 0 3px var(--accent-weak)}
.wbtn:hover{border-color:var(--accent)}
.searchbox:focus{border-color:var(--accent);box-shadow:0 0 0 2px var(--accent-weak)}
input:focus, textarea:focus, select:focus{outline:none;border-color:var(--accent)!important;box-shadow:0 0 0 2px var(--accent-weak)}
.window.focus.white-corners{border-color:var(--accent)}
.taskbar-app.active{border-bottom:2px solid var(--accent)}
.app-tile:hover{outline:2px solid var(--accent)}
.context-menu-item:hover{color:#fff}

/* Boot logs */
.boot-logs{margin-top:12px;text-align:left;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);border-radius:10px;max-height:140px;overflow:auto;padding:10px;font-size:12px;color:#cfd3d7}
.boot-logs .log-line{opacity:.85}
.boot-logs .ok{color:#8be08b}
.boot-logs .warn{color:#ffd37a}
.boot-logs .err{color:#ff8a8a}

/* Shutdown overlay styling */
.shutdown-screen {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.45);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  z-index: 100000;
  color: #fff;
}
.shutdown-screen.off {
  background: #000; /* powered-off state: no UI visible */
  backdrop-filter: none;
  -webkit-backdrop-filter: none;
}
.shutdown-card {
  width: 420px;
  max-width: 92vw;
  padding: 26px 22px;
  border-radius: var(--radius);
  background: rgba(20,22,25,0.92);
  box-shadow: 0 20px 48px rgba(0,0,0,0.7);
  border: 1px solid rgba(255,255,255,0.08);
  text-align: center;
}
.white-corners-strong{border:2px solid rgba(255,255,255,0.95);border-radius:var(--radius)}
.shutdown-title { font-weight: 800; font-size: 18px; margin-bottom: 8px; }
.shutdown-sub { color: var(--muted); margin-bottom: 16px; font-size: 14px; }
.shutdown-spinner { display:inline-block;width:14px;height:14px;border-radius:50%;border:2px solid rgba(255,255,255,0.15);border-top-color:#fff;animation:spin 1s linear infinite;margin-right:8px;vertical-align:middle;}
.power-on-hint { opacity: 0.85; }

/* Power-on prompt styles */
.power-on-wrap { text-align:center; color:#fff; }
.power-on-title { font-weight:800; font-size:22px; margin-bottom:10px; }
.power-on-sub { color:var(--muted); font-size:14px; margin-bottom:16px; }
.power-on-btn { width:68px; height:68px; border-radius:50%; border:2px solid rgba(255,255,255,0.25); display:inline-flex; align-items:center; justify-content:center; cursor:pointer; position:relative; }
.power-on-btn::after { content:""; position:absolute; inset:-4px; border-radius:50%; border:3px solid rgba(255,255,255,0.18); }
.power-on-glyph { font-size:24px; }
.hold-ring { position:absolute; inset:-6px; border-radius:50%; border:3px solid rgba(255,255,255,0.45); transform:scale(0); opacity:0.9; transition:transform .15s linear; }

.thumb{width:100%;height:120px;border-radius:8px;background-size:cover;background-position:center;border:1px solid rgba(255,255,255,0.03);display:block}
.file-row{display:flex;gap:8px;align-items:center;padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)}
.file-meta{flex:1}
.file-actions{display:flex;gap:6px}

.context-menu {
  position: absolute;
  background: rgba(30, 32, 35, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 10px;
  padding: 8px 0;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  z-index: 90050;
  min-width: 180px;
  display: none;
}

.context-menu-item {
  padding: 8px 16px;
  cursor: pointer;
  font-size: 14px;
  color: #fff;
  transition: all 0.2s ease;
}

.context-menu-item:hover {
  background: rgba(255,255,255,0.1);
}

.canvas-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.canvas-tools {
  display: flex;
  gap: 8px;
  margin-bottom: 10px;
  align-items: center;
  flex-wrap: wrap;
}



.canvas-wrapper {
  flex: 0 0 auto; /* don't stretch; fit the canvas */
  position: relative;
  width: 1920px;
  height: 1080px;
  background: #1a1c20; /* match canvas bg to hide any seam */
  border: none; /* remove 1px gap caused by border */
  border-radius: 8px;
  overflow: hidden;
  min-height: 0;
}

#paintCanvas {
  background: #1a1c20;
  cursor: crosshair;
  width: 100%;
  height: 100%;
  display: block;
}

.color-picker {
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: 2px solid rgba(255,255,255,0.2);
  cursor: pointer;
}

.brush-size {
  width: 80px;
}

.tool-btn {
  font-size: 20px;
  cursor: pointer;
  padding: 5px;
  border-radius: 5px;
  transition: background 0.2s;
}

.tool-btn:hover, .tool-btn.active {
  background: rgba(255,255,255,0.1);
}

#installScreen {
  position: fixed;
  inset: 0;
  background: linear-gradient(135deg, #0f1720 0%, #171a1f 60%);
  z-index: 999999;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: white;
  font-family: "Inter", sans-serif;
}

.install-container {
  width: 600px;
  max-width: 90%;
  background: rgba(20, 22, 25, 0.8);
  border-radius: 18px;
  padding: 30px;
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  backdrop-filter: blur(10px);
}

.install-header {
  text-align: center;
  margin-bottom: 30px;
}

.install-header h1 {
  font-size: 28px;
  margin-bottom: 10px;
}

.install-header p {
  color: var(--muted);
  font-size: 15px;
}

.install-steps {
  margin-bottom: 30px;
}

.install-step {
  padding: 15px;
  border-radius: 10px;
  margin-bottom: 10px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.05);
  transition: all 0.3s ease;
}

.install-step.active {
  border-color: rgba(255,255,255,0.2);
  background: rgba(255,255,255,0.07);
}

.install-footer {
  display: flex;
  justify-content: space-between;
  margin-top: 20px;
}

.install-btn {
  padding: 10px 20px;
  border-radius: 8px;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
  color: white;
  cursor: pointer;
  transition: background 0.2s;
}

.install-btn:hover {
  background: rgba(255,255,255,0.15);
}

.install-btn.primary {
  background: rgba(255,255,255,0.2);
}

.icons-container {
  display: flex;
  flex-direction: column;
  height: calc(100vh - 100px);
  overflow-y: auto;
  padding-right: 8px;
}

.icons-container::-webkit-scrollbar {
  width: 6px;
}

.icons-container::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.1);
  border-radius: 3px;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.icon {
  animation: fadeIn 0.3s ease-out;
}

/* Click animation for desktop icons */
@keyframes clickBounce {
  0%   { transform: translateY(0) scale(1); box-shadow: 0 0 0 rgba(255,255,255,0); }
  45%  { transform: translateY(2px) scale(0.94); box-shadow: 0 10px 26px rgba(0,0,0,0.55); }
  85%  { transform: translateY(-2px) scale(1.04); }
  100% { transform: translateY(0) scale(1); }
}
.icon.clicked { animation: clickBounce 320ms cubic-bezier(.2,.9,.2,1); }
.icon:active { transform: translateY(2px) scale(0.98); }

@keyframes desktopAppear {
  from { opacity: 0; transform: translateY(20px); }
  to { opacity: 1; transform: translateY(0); }
}

.desktop-appear {
  animation: desktopAppear 0.8s ease-out forwards;
}

/* Boot desktop reveal animations */
@keyframes taskbarIn {
  from { opacity: 0; transform: translateY(30px); }
  to   { opacity: 1; transform: translateY(0); }
}
@keyframes iconPop {
  0%   { opacity: 0; transform: scale(0.92) translateY(14px); }
  60%  { opacity: 1; transform: scale(1.02) translateY(0); }
  100% { opacity: 1; transform: scale(1); }
}
@keyframes chipIn {
  from { opacity: 0; transform: translateY(8px); }
  to   { opacity: 1; transform: translateY(0); }
}
body.boot-reveal .taskbar { animation: taskbarIn 0.7s cubic-bezier(.2,.9,.2,1) both; }
body.boot-reveal #desktopIcons .icon { animation: iconPop 0.55s cubic-bezier(.2,.9,.2,1) both; }
body.boot-reveal .taskbar .task-mid > * { animation: chipIn 0.45s ease-out both; }

@media (min-width: 1200px) {
  .icons {
    flex-direction: row;
    flex-wrap: wrap;
    align-content: flex-start;
    width: auto;
    max-width: 800px;
    gap: 20px;
  }
  .icon {
    width: 140px; /* Match windowed width to avoid narrow icons in fullscreen */
  }
}

.icon.text-only {
  flex-direction: column;
  align-items: flex-start;
  padding: 12px;
}

.icon.text-only .img {
  display: none;
}

.icon.text-only label {
  font-size: 14px;
  margin-top: 8px;
}

.icon.emoji-mode .img {
  font-size: 24px;
  line-height: 1;
}

/* NEW STYLES FOR IMPROVEMENTS */
.media-player {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.media-controls {
  display: flex;
  gap: 10px;
  padding: 10px;
  background: rgba(0,0,0,0.3);
  border-radius: 8px;
  margin-bottom: 10px;
  align-items: center;
}

.media-player video, .media-player audio {
  width: 100%;
  border-radius: 8px;
  background: #000;
  flex: 1;
}

.media-progress {
  flex: 1;
  height: 8px;
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.media-progress-bar {
  position: absolute;
  height: 100%;
  background: rgba(255,255,255,0.7);
  width: 0%;
}

.file-manager-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 12px;
  padding: 10px;
}

.file-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px;
  border-radius: 8px;
  cursor: pointer;
  transition: background 0.2s;
}

.file-item:hover {
  background: rgba(255,255,255,0.05);
}

.file-icon {
  width: 48px;
  height: 48px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  margin-bottom: 8px;
  border-radius: 8px;
  background: rgba(255,255,255,0.05);
}

.file-name {
  font-size: 12px;
  text-align: center;
  word-break: break-word;
  max-width: 100%;
}

.browser-url-bar {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}

.browser-url-input {
  flex: 1;
  padding: 10px 14px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.07);
  background: rgba(10,13,20,0.13);
  color: #fff;
}

.browser-go-button {
  padding: 10px 16px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.07);
  background: linear-gradient(180deg, rgba(255,255,255,0.037), rgba(255,255,255,0));
  color: #fff;
  font-weight: 600;
  cursor: pointer;
}

.browser-loading-bar {
  height: 2px;
  width: 0%;
  background: var(--accent);
  transition: width 0.3s;
  margin-bottom: 10px;
}

.desktop-icons-grid {
  display: flex;
  flex-direction: column;   /* fill downward first */
  flex-wrap: wrap;          /* then wrap to next column */
  align-content: flex-start;/* columns from the left */
  gap: 14px;
  padding: 28px;
  height: calc(100vh - 76px); /* leave space for full-width taskbar + bottom gap */
  overflow: visible;        /* no scroll on desktop */
}

.files-app-container {
  display: flex;
  height: 100%;
  gap: 16px;
}

.files-sidebar {
  width: 200px;
  background: rgba(255,255,255,0.02);
  border-radius: 12px;
  padding: 12px;
}

.files-content {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.files-toolbar {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
}

.files-view {
  flex: 1;
  overflow: auto;
  background: rgba(255,255,255,0.01);
  border-radius: 12px;
  padding: 12px;
}

.file-context-menu {
  position: absolute;
  background: rgba(30, 32, 35, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 10px;
  padding: 8px 0;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
  z-index: 90050;
  min-width: 180px;
  display: none;
}

.file-context-menu-item {
  padding: 8px 16px;
  cursor: pointer;
  font-size: 14px;
  color: #fff;
  transition: all 0.2s ease;
}

.file-context-menu-item:hover {
  background: rgba(255,255,255,0.1);
}

.folder-item {
  padding: 8px 12px;
  border-radius: 8px;
  cursor: pointer;
  margin-bottom: 4px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.folder-item:hover, .folder-item.active {
  background: rgba(255,255,255,0.05);
}

.file-preview {
  max-width: 100%;
  max-height: 400px;
  margin: 0 auto;
  display: block;
}

.text-preview {
  white-space: pre-wrap;
  font-family: monospace;
  background: rgba(0,0,0,0.2);
  padding: 12px;
  border-radius: 8px;
  max-height: 400px;
  overflow: auto;
}

.binary-preview {
  text-align: center;
  padding: 20px;
  color: var(--muted);
}

/* Settings app (Windows-like) */
.settings-container { display:flex; height:100%; gap:16px; }
.settings-nav {
  width: 220px;
  background: rgba(255,255,255,0.02);
  border-radius: 12px;
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.settings-nav-title { font-weight:800; font-size:18px; margin-bottom:8px; }
.settings-nav-item {
  padding: 10px 12px;
  border-radius: 10px;
  cursor: pointer;
  color: #fff;
  border: 1px solid rgba(255,255,255,0.05);
  background: linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0));
}
.settings-nav-item:hover { background: rgba(255,255,255,0.08); }
.settings-nav-item.active { background: rgba(255,255,255,0.14); border-color: rgba(255,255,255,0.14); }

.settings-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 14px;
  min-height: 0; /* allow inner page to scroll */
  overflow: hidden; /* keep scroll on page, not container */
}
.settings-section { background: rgba(255,255,255,0.01); border-radius: 12px; padding: 14px; border:1px solid rgba(255,255,255,0.04); }
.settings-h1 { font-weight:800; font-size:22px; }
.settings-h2 { font-weight:700; font-size:16px; color: var(--muted); margin-top:6px; }
.kv { display:grid; grid-template-columns: 180px 1fr; gap: 8px 14px; margin-top:12px; }
.kv .k { color: var(--muted); }
.kv .v { font-weight:600; }

/* Settings hero + page animation */
.settings-hero { display:flex; align-items:center; gap:14px; }
.settings-hero-logo {
  width:56px; height:56px; border-radius:14px;
  background: linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.02));
  display:flex; align-items:center; justify-content:center; font-weight:900; font-size:18px;
  border:1px solid rgba(255,255,255,0.08);
  box-shadow: 0 8px 24px rgba(0,0,0,0.35) inset, 0 6px 18px rgba(0,0,0,0.25);
}
.settings-hero-text { display:flex; flex-direction:column; }
.settings-hero-title { font-size:22px; font-weight:800; }
.settings-hero-sub { color: var(--muted); font-size:13px; }
.settings-version-badge {
  margin-top:8px; display:inline-flex; align-items:center; gap:8px;
  padding:6px 10px; border-radius:10px;
  background: rgba(255,255,255,0.06);
  border:1px solid rgba(255,255,255,0.08);
  font-weight:700;
}

.settings-page { position:relative; overflow:auto; flex:1; min-height:0; }
.page-enter { animation: pageIn 420ms cubic-bezier(.2,.75,.25,1) both; }
@keyframes pageIn {
  0% { opacity:0; transform: translateY(8px) scale(0.985); filter: blur(2px); }
  60% { opacity:1; transform: translateY(0) scale(1.0); filter: blur(0.6px); }
  100% { opacity:1; transform: none; filter: none; }
}

.wifi-panel{
  position:fixed;right:18px;bottom:88px;width:340px;max-width:92vw;
  background:rgba(24,26,30,0.96);
  backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);
  border-radius:var(--radius); /* match Start menu radius (18px) */
  border:1px solid rgba(255,255,255,0.95); /* match Start menu white border */
  box-shadow:0 24px 64px rgba(0,0,0,0.65);
  z-index:90025;overflow:hidden
}
.wifi-header{display:flex;align-items:center;gap:10px;padding:12px 14px;border-bottom:1px solid rgba(255,255,255,0.06)}
.wifi-title{font-weight:800}
.wifi-list{max-height:300px;overflow:auto;padding:6px}
.wifi-net{display:flex;align-items:center;gap:10px;padding:10px 10px;border-radius:10px;cursor:pointer}
.wifi-net:hover{background:rgba(255,255,255,0.06)}
.wifi-icon{width:24px;height:24px;display:flex;align-items:center;justify-content:center}
.wifi-right{margin-left:auto;display:flex;align-items:center;gap:8px}
.chip{padding:4px 8px;border-radius:8px;background:rgba(255,255,255,0.08);font-size:12px}
.btn-ghost{padding:6px 10px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.14);color:#fff;font-weight:600;cursor:pointer}
.btn-ghost:hover{background:rgba(255,255,255,0.08)}
.sig-dots{display:inline-flex;gap:6px;vertical-align:middle}
.sig-dot{width:8px;height:8px;border-radius:50%;background:rgba(255,255,255,0.24)}
.sig-dot.active{background:#fff}

</style>
</head>
<body>
<!-- Boot chime audio: place 'boot-chime.mp3' next to this HTML file or update the src -->
<audio id="bootChime" src="RTOSBOOTFINAL1.0.mp3" preload="auto" style="display:none"></audio>
<!-- Shutdown chime audio -->
<audio id="shutdownChime" src="RTOSSHUTDOWNFINAL1.0.mp3" preload="auto" style="display:none"></audio>
<!-- Installation screen removed: app starts directly at boot screen -->

<!-- Boot screen (shown after installation) -->
<div id="boot"><div class="boot-card white-corners neon-outline"><div class="logo">RT OS</div>
<div class="boot-sub">Loading RT OS — sleek, modern, and customizable</div>
<div class="progress-wrap" role="progressbar" aria-valuemin="0" aria-valuemax="100"><div id="progress" class="progress-bar"></div></div>
<div class="boot-meta"><div id="bootStatus"><span class="boot-spinner"></span> Initializing modules…</div><div id="bootPct">0%</div></div>
</div></div>

<!-- Main desktop -->
<div id="desktop">
<div class="wallpaper" id="wallpaperEl"></div>
<div class="desktop-inner" id="desktopInner" style="opacity:0;">
<div style="display:flex; align-items:flex-start;">
<div class="desktop-icons-grid" id="desktopIcons">
  <div class="icon white-corners" data-app="browser" data-label="Browser"><div class="img">BR</div><label>Browser</label></div>
  <div class="icon white-corners" data-app="files" data-label="Files"><div class="img">FL</div><label>Files</label></div>
  <div class="icon white-corners" data-app="settings" data-label="Settings"><div class="img">ST</div><label>Settings</label></div>
  <div class="icon white-corners" data-app="notes" data-label="Notepad"><div class="img">NP</div><label>Notepad</label></div>
  <div class="icon white-corners" data-app="trash" data-label="Trash"><div class="img">TR</div><label>Trash</label></div>
</div>
<div style="flex:1"></div>
</div>
<div class="taskbar white-corners" id="taskbar">
<div class="start-btn" id="startBtn">RT</div>
<button class="searchbtn" id="taskbarSearchBtn" aria-label="Search" title="Search">
  <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <circle cx="11" cy="11" r="6" stroke="currentColor" stroke-width="2.2" />
    <line x1="16" y1="16" x2="21" y2="21" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" />
  </svg>
  </button>
<input class="searchbox" id="taskbarSearch" type="text" placeholder="Search" autocomplete="off" />
<div class="task-mid" id="taskMid"></div>
<div class="task-right" style="display:flex;gap:8px;align-items:center;">
<div id="volumeIndicator" title="Volume" aria-label="Volume" tabindex="0"></div>
<div id="wifiIndicator" title="Wi‑Fi" aria-label="Wi‑Fi status" tabindex="0"></div>
<div id="timeDisplay" style="font-weight:600;"></div>
</div>
</div>
</div>
</div>

<!-- Start Menu -->
<div id="startMenu" class="white-corners" role="menu" aria-hidden="true">
<h3 class="start-title">RT OS</h3>
<div class="start-grid">
<div class="app-tile" data-app="browser">Browser</div>
<div class="app-tile" data-app="files">Files</div>
<div class="app-tile" data-app="settings">Settings</div>
<div class="app-tile" data-app="notes">Notepad</div>
<div class="app-tile" data-app="trash">Trash</div>
<div class="app-tile" data-app="paint">Paint</div>
<div class="app-tile" data-app="calc">Calculator</div>
<div class="app-tile" data-app="clock">Clock</div>
<div class="app-tile" data-app="media">Media Player</div>
<div class="app-tile" id="powerBtn">Power</div>
</div>
</div>

<!-- Search Results -->
<div id="searchResults" aria-live="polite" aria-atomic="true"></div>

<!-- Context Menu -->
<div id="contextMenu" class="context-menu">
  <div class="context-menu-item" id="cmAddToDesktop">Add to Desktop</div>
  <div class="context-menu-item" id="cmRemoveFromDesktop">Remove from Desktop</div>
  <div class="context-menu-item" id="cmRemoveShortcut">Remove from Desktop</div>
  <div class="context-menu-item" id="cmToggleIconStyle">Show Emoji Icons</div>
  <div class="context-menu-item" id="cmRefresh">Refresh</div>
  <div class="context-menu-item" id="cmPersonalize">Personalize</div>
  <div class="context-menu-item" id="cmAppProperties">Properties</div>
</div>

<!-- File Context Menu -->
<div id="fileContextMenu" class="file-context-menu">
  <div class="file-context-menu-item" id="fileCtxOpen">Open</div>
  <div class="file-context-menu-item" id="fileCtxAddToDesktop">Add to Desktop</div>
  <div class="file-context-menu-item" id="fileCtxRename">Rename</div>
  <div class="file-context-menu-item" id="fileCtxDelete">Move to Trash</div>
  <div class="file-context-menu-item" id="fileCtxProperties">Properties</div>
</div>

<script>
/* RT OS — Enhanced with all requested improvements */
const MAX_WINDOWS = 30;
const state = {
  z: 100,
  openWindows: {},
  settings: {
    wallpaper: "gradient-1",
    neon: true,
    accentColor: "#ffffff",
    accent: "system",
    iconStyle: "text",
    taskbarStyle: "full" // full | centered
  },
  wallpapers: {
    "gradient-1": "linear-gradient(135deg,#111216 0%, #1b1d20 60%)",
    "gradient-2": "linear-gradient(135deg,#0f1720 0%, #171a1f 60%)",
    "pattern-1": "radial-gradient(circle at 15% 20%, rgba(255,255,255,0.03), transparent 3%), linear-gradient(180deg,#0d0f11,#121416)",
    "gradient-3": "linear-gradient(135deg,#12131a 0%, #171b29 60%)",
    "aurora": "radial-gradient(circle at 20% 10%, rgba(90,167,255,0.15), transparent 35%), radial-gradient(circle at 80% 30%, rgba(255,91,149,0.12), transparent 40%), linear-gradient(180deg,#0d0f13,#13161b)",
    "vapor": "radial-gradient(600px 200px at 10% 90%, rgba(124,58,237,0.18), transparent 55%), linear-gradient(180deg,#0b0d11,#151822)",
    "grid-dark": "radial-gradient(circle at 5% 10%, rgba(255,255,255,0.03), transparent 4%), repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 20px), linear-gradient(180deg,#0d0f11,#14161a)",
    "stripes": "repeating-linear-gradient(45deg, rgba(255,255,255,0.04) 0 10px, transparent 10px 20px), linear-gradient(180deg,#0d0f11,#14161a)",
    // Accent-themed variants
    "red-aurora": "radial-gradient(circle at 25% 15%, rgba(255,90,95,0.18), transparent 35%), radial-gradient(circle at 70% 40%, rgba(255,165,0,0.12), transparent 45%), linear-gradient(180deg,#0d0f13,#141217)",
    "green-aurora": "radial-gradient(circle at 20% 20%, rgba(57,217,138,0.2), transparent 40%), radial-gradient(circle at 80% 30%, rgba(46,201,201,0.14), transparent 45%), linear-gradient(180deg,#0b0f0e,#111a15)",
    "pink-aurora": "radial-gradient(circle at 30% 12%, rgba(255,107,200,0.2), transparent 38%), radial-gradient(circle at 75% 42%, rgba(155,123,255,0.14), transparent 45%), linear-gradient(180deg,#0e0b11,#16131c)",
    "purple-aurora": "radial-gradient(circle at 22% 18%, rgba(155,123,255,0.22), transparent 40%), radial-gradient(circle at 78% 38%, rgba(90,167,255,0.12), transparent 45%), linear-gradient(180deg,#0e0e14,#151527)",
    "orange-aurora": "radial-gradient(circle at 25% 20%, rgba(255,159,69,0.22), transparent 38%), radial-gradient(circle at 75% 35%, rgba(255,90,95,0.14), transparent 44%), linear-gradient(180deg,#0f0c0b,#1a1411)",
    "teal-aurora": "radial-gradient(circle at 20% 25%, rgba(46,201,201,0.22), transparent 38%), radial-gradient(circle at 70% 38%, rgba(90,167,255,0.12), transparent 44%), linear-gradient(180deg,#0b0f11,#111b1e)",
    // Extras
    "blue-aurora": "radial-gradient(circle at 20% 10%, rgba(90,167,255,0.22), transparent 35%), radial-gradient(circle at 80% 30%, rgba(46,201,201,0.12), transparent 45%), linear-gradient(180deg,#0d0f13,#121827)",
    "red-vapor": "radial-gradient(520px 200px at 15% 85%, rgba(255,90,95,0.2), transparent 55%), linear-gradient(180deg,#0b0b0d,#191316)",
    "green-vapor": "radial-gradient(520px 200px at 15% 85%, rgba(57,217,138,0.22), transparent 55%), linear-gradient(180deg,#08100c,#121c16)",
    "pink-vapor": "radial-gradient(520px 200px at 15% 85%, rgba(255,107,200,0.22), transparent 55%), linear-gradient(180deg,#0c0a0f,#1a1421)",
    "purple-vapor": "radial-gradient(520px 200px at 15% 85%, rgba(155,123,255,0.22), transparent 55%), linear-gradient(180deg,#0a0a12,#16182a)",
    "orange-vapor": "radial-gradient(520px 200px at 15% 85%, rgba(255,159,69,0.22), transparent 55%), linear-gradient(180deg,#0f0c0a,#1f1812)",
    "teal-vapor": "radial-gradient(520px 200px at 15% 85%, rgba(46,201,201,0.22), transparent 55%), linear-gradient(180deg,#081013,#122127)",
    "matrix": "repeating-linear-gradient(0deg, rgba(57,217,138,0.12) 0 1px, transparent 1px 20px), linear-gradient(180deg,#080b09,#101411)",
    "nebula-pink": "radial-gradient(600px 240px at 15% 80%, rgba(255,107,200,0.18), transparent 55%), radial-gradient(400px 200px at 85% 20%, rgba(155,123,255,0.16), transparent 60%), linear-gradient(180deg,#0b0b10,#161726)"
  },
  files: {},
  trash: {},
  // Wi‑Fi system state
  wifi: { connected: false, network: null, connecting: false, target: null, connectEndAt: null },
  wifiNetworks: {
    'rt-hotspot': { ssid: 'RT Hotspot', strength: 4, latency: 200, jitter: 80, packetLoss: 0.02 },
    'terrible-hotstop': { ssid: 'Terrible Hotstop', strength: 1, latency: 1800, jitter: 1200, packetLoss: 0.35 }
  },
  // Audio
  volume: 100,
  installedApps: {
    "browser": { name: "Browser", show: true, system: true, emoji: "🌐", initials: "BR" },
    "files": { name: "Files", show: true, system: true, emoji: "📁", initials: "FL" },
    "settings": { name: "Settings", show: true, system: true, emoji: "⚙️", initials: "ST" },
    "notes": { name: "Notepad", show: true, system: true, emoji: "📝", initials: "NP" },
    "trash": { name: "Trash", show: true, system: true, emoji: "🗑️", initials: "TR" },
    "cmd": { name: "CMD", show: false, system: false, emoji: "💻", initials: "CM" },
    "calc": { name: "Calculator", show: false, system: false, emoji: "🧮", initials: "CA" },
    "clock": { name: "Clock", show: false, system: false, emoji: "⏰", initials: "CL" },
    "paint": { name: "Paint", show: false, system: false, emoji: "🎨", initials: "PA" },
    "media": { name: "Media Player", show: false, system: false, emoji: "🎵", initials: "MP" }
  },
  desktopIcons: ["browser", "files", "settings", "notes", "trash"],
  // Shortcuts to specific files shown on the desktop (e.g., .nt notes)
  desktopShortcuts: [],
  folders: ["Documents", "Pictures", "Videos", "Music"]
};

// ----------------------
// RT Accounts & Persistence
// ----------------------
// Data in localStorage keys:
//  rtos.accounts = { users: { [id]: { id, name, avatarDataURL, passHash } }, current: id|null }
//  rtos.user.<id>.state = JSON for persistable OS state

let __accounts = { users: {}, current: null };
let __autosaveTimer = null;

function loadAccounts() {
  try {
    const raw = localStorage.getItem('rtos.accounts');
    __accounts = raw ? JSON.parse(raw) : { users: {}, current: null };
    if (!__accounts.users) __accounts.users = {};
  } catch(_) {
    __accounts = { users: {}, current: null };
  }
}

function saveAccounts() {
  try { localStorage.setItem('rtos.accounts', JSON.stringify(__accounts)); } catch(_) {}
}

function getCurrentUser() {
  return __accounts.current ? __accounts.users[__accounts.current] || null : null;
}

function getCurrentUsername() {
  const u = getCurrentUser();
  return u && u.name ? u.name : 'guest';
}

function findAccountByName(name) {
  if (!name) return null;
  const users = __accounts && __accounts.users ? __accounts.users : {};
  const match = Object.values(users).find(u => (u.name||'').toLowerCase() === String(name).toLowerCase());
  return match || null;
}

// Very simple hash to avoid storing plaintext; not cryptographically strong.
function simpleHash(str='') {
  let h = 0; for (let i=0; i<str.length; i++) { h = (h*31 + str.charCodeAt(i))|0; } return String(h>>>0);
}

function createAccount(name, avatarDataURL, password) {
  loadAccounts();
  // Require non-empty name and password
  if (!name || !String(name).trim()) return false;
  if (!password || !String(password)) return false;
  // If an account with the same name exists, sign in instead of creating a duplicate
  const existing = findAccountByName(name);
  if (existing) {
    const res = signInAccount(existing.id, password||'');
    return res.ok;
  }
  const id = 'u' + Date.now().toString(36) + Math.random().toString(36).slice(2,6);
  __accounts.users[id] = { id, name: (name||'User'), avatarDataURL: avatarDataURL||'', passHash: simpleHash(password||'') };
  __accounts.current = id;
  saveAccounts();
  // Initialize empty state for new user
  saveUserState();
  applyUserState();
}

function signInAccount(id, password) {
  loadAccounts();
  const u = __accounts.users[id];
  if (!u) return { ok:false, msg:'Account not found' };
  if (u.passHash !== simpleHash(password||'')) return { ok:false, msg:'Incorrect password' };
  try { saveUserState(); } catch(_) {}
  __accounts.current = id; saveAccounts();
  applyUserState();
  return { ok:true };
}

function signOutAccount() {
  // Keep user data; just unset current
  try { saveUserState(); } catch(_) {}
  __accounts.current = null; saveAccounts();
}

function deleteAccount(id) {
  loadAccounts();
  if (__accounts.current === id) __accounts.current = null;
  try { localStorage.removeItem('rtos.user.'+id+'.state'); } catch(_) {}
  delete __accounts.users[id];
  saveAccounts();
}

function getPersistableState() {
  // Extract only user data, not runtime-only fields
  return {
    settings: state.settings,
    files: state.files || {},
    desktopIcons: state.desktopIcons || [],
    trash: state.trash || {},
    wallpapers: state.wallpapers || {},
    folders: state.folders || [],
    wifi: state.wifi || null
  };
}

function applyPersistedState(saved) {
  if (!saved) return;
  try {
    // Merge shallow to avoid losing runtime scaffolding
    state.settings = Object.assign({}, state.settings, saved.settings||{});
    state.files = Object.assign({}, saved.files||{});
    state.desktopIcons = Array.isArray(saved.desktopIcons) ? saved.desktopIcons.slice() : (state.desktopIcons||[]);
    state.trash = Object.assign({}, saved.trash||{});
    state.wallpapers = Object.assign({}, state.wallpapers||{}, saved.wallpapers||{});
    state.folders = Array.isArray(saved.folders) ? saved.folders.slice() : (state.folders||[]);
    state.wifi = saved.wifi || state.wifi;
  } catch(_) {}
}

function saveUserState() {
  const u = getCurrentUser();
  if (!u) return;
  try { localStorage.setItem('rtos.user.'+u.id+'.state', JSON.stringify(getPersistableState())); } catch(_) {}
}

function loadUserState() {
  const u = getCurrentUser();
  if (!u) return null;
  try { const raw = localStorage.getItem('rtos.user.'+u.id+'.state'); return raw ? JSON.parse(raw) : null; } catch(_) { return null; }
}

function applyUserState() {
  const data = loadUserState();
  if (data) { applyPersistedState(data); }
  // Re-apply visuals and UI
  try { applyWallpaper(); } catch(_) {}
  try { applyAccent(); } catch(_) {}
  try { renderDesktopIcons(); } catch(_) {}
  try { if (typeof updateStartMenu === 'function') updateStartMenu(); } catch(_) {}
  try { renderWifiIndicator(); } catch(_) {}
  // Ensure taskbar layout (centered/full) is re-applied after settings load
  try { applyTaskbarStyle(false); } catch(_) {}
  // Reconfigure autohide wrapper for centered mode immediately and after a tick (avoid race with boot animations)
  try { setupTaskbarAutohide(); } catch(_) {}
  setTimeout(() => { try { setupTaskbarAutohide(); } catch(_) {} }, 0);
}

function startAutosave() {
  if (__autosaveTimer) { clearInterval(__autosaveTimer); __autosaveTimer = null; }
  // Save every 2.5s while a user is signed in
  __autosaveTimer = setInterval(() => { if (getCurrentUser()) saveUserState(); }, 2500);
  window.addEventListener('beforeunload', () => { try { saveUserState(); } catch(_) {} });
}

// Initialize accounts early
loadAccounts();
applyUserState();
startAutosave();

// Danger: wipe all RT OS data
function wipeAllData() {
  try {
    // Remove per-user states
    loadAccounts();
    const ids = Object.keys((__accounts && __accounts.users) || {});
    ids.forEach(id => { try { localStorage.removeItem('rtos.user.'+id+'.state'); } catch(_) {} });
    // Remove accounts registry
    try { localStorage.removeItem('rtos.accounts'); } catch(_) {}
  } catch(_) {}
}

function wipeAccountByName(name) {
  if (!name) return { ok:false, msg:'Provide an account name' };
  loadAccounts();
  const u = findAccountByName(name);
  if (!u) return { ok:false, msg:'Account not found' };
  try { localStorage.removeItem('rtos.user.'+u.id+'.state'); } catch(_) {}
  delete __accounts.users[u.id];
  if (__accounts.current === u.id) __accounts.current = null;
  saveAccounts();
  return { ok:true };
}

// Installation removed — starting directly at boot

// Apply wallpaper
const wallpaperEl = document.getElementById("wallpaperEl");
function applyWallpaper() {
  try {
    let wp = state.wallpapers[state.settings.wallpaper];
    if (wp && wp.startsWith("url(")) {
      if (!/^url\(('|")/.test(wp)) {
        wp = wp.replace(/^url\(([^'"])(.*)\)$/, 'url("$1$2")');
      }
    }
    wallpaperEl.style.background = wp || state.wallpapers["gradient-1"];
  } catch(e) {
    wallpaperEl.style.background = state.wallpapers["gradient-1"];
  }
}
applyWallpaper();

// Accent application (dark-only base)
function applyAccent() {
  const color = state.settings.accentColor || '#5aa7ff';
  const root = document.documentElement;
  root.style.setProperty('--accent', color);
  // Optional derived accents
  try {
    // Slightly transparent accent for glows
    root.style.setProperty('--accent-weak', color + '33');
  } catch(_) {}
}
applyAccent();

// Taskbar style application
function applyTaskbarStyle(animate = true) {
  try {
    const tb = document.getElementById('taskbar');
    const mid = document.getElementById('taskMid');
    const left = document.getElementById('taskLeft');
    const right = document.getElementById('taskRight');
    const searchEl = document.getElementById('taskbarSearch');
    if (!tb) return;
    const centered = state.settings.taskbarStyle === 'centered';
    tb.classList.toggle('centered', centered);
    // Apply inline layout guards to ensure compact width in centered mode
    if (centered) {
      tb.classList.add('centered');
      // Enable autohide in centered mode so it overlays full-screen apps and hides when idle
      tb.classList.add('autohide');
      tb.classList.remove('hidden');
      tb.style.left = '';
      tb.style.right = '';
      // Do NOT set inline transform; CSS .taskbar.centered controls transform for animation
      tb.style.transform = '';
      tb.style.width = 'max-content';
      tb.style.maxWidth = 'calc(100vw - 24px)';
      if (mid) mid.style.flex = '0 1 auto';
      if (left) left.style.flex = '0 0 auto';
      if (right) right.style.flex = '0 0 auto';
    } else {
      tb.classList.remove('centered');
      tb.classList.remove('autohide','hidden');
      tb.style.left = '0';
      tb.style.right = '0';
      tb.style.transform = '';
      tb.style.width = '';
      tb.style.maxWidth = '';
      if (mid) mid.style.flex = '';
      if (left) left.style.flex = '';
      if (right) right.style.flex = '';
    }
    // Maintain compact search state in centered mode + placeholder per style
    try {
      if (searchEl) {
        if (!centered) {
          searchEl.classList.remove('expanded');
          if (searchEl.placeholder !== 'Search RT OS, apps or web...') searchEl.placeholder = 'Search RT OS, apps or web...';
        } else {
          const active = document.activeElement === searchEl;
          if (active) {
            searchEl.classList.add('expanded');
            if (searchEl.placeholder !== 'Search RT OS, apps or web...') searchEl.placeholder = 'Search RT OS, apps or web...';
          } else {
            searchEl.classList.remove('expanded');
            if (searchEl.placeholder !== 'Search') searchEl.placeholder = 'Search';
            try { searchEl.value = ''; if (typeof hideSearch === 'function') hideSearch(true); } catch(_) {}
          }
        }
      }
    } catch(_) {}
    // Smooth child-only slide animation (no fade of the whole bar)
    if (animate) {
      // Slide-in animation using child elements (stagger app icons only)
      tb.classList.add('dock-anim');
      if (mid) {
        let idx = 0;
        Array.from(mid.children).forEach(el => el && el.style && el.style.setProperty('--i', idx++));
      }
      setTimeout(() => {
        tb.classList.remove('dock-anim');
        if (mid) {
          Array.from(mid.children).forEach(el => el && el.style && el.style.removeProperty('--i'));
        }
      }, 360);
    }
    // After style changes, refresh frames of already-open maximized windows
    try { refreshMaximizedWindowsFrame(); } catch(_) {}
    // Reconfigure autohide behavior for centered mode
    try { setupTaskbarAutohide(); } catch(_) {}
  } catch(_) {}
}
applyTaskbarStyle();

// Keep taskbar hidden until desktop is revealed
try { const __tbInit = document.getElementById('taskbar'); if (__tbInit) __tbInit.classList.add('preboot-hidden'); } catch(_) {}

// Ensure taskbar is not constrained by desktop stacking contexts: move it under <body>
function promoteTaskbarToBody() {
  try {
    const tb = document.getElementById('taskbar');
    if (tb && tb.parentElement !== document.body) {
      document.body.appendChild(tb);
    }
  } catch (_) {}
}
promoteTaskbarToBody();

// Resize any already-open maximized windows to the correct frame
function refreshMaximizedWindowsFrame() {
  try {
    const tbEl = document.getElementById('taskbar');
    const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
    const insetX = 0, insetY = 0;
    const width = Math.max(200, window.innerWidth - insetX*2);
    const height = centeredAuto
      ? Math.max(160, Math.round(window.innerHeight - insetY))
      : Math.max(160, Math.round((tbEl ? tbEl.getBoundingClientRect().top : window.innerHeight) - insetY));
    document.querySelectorAll('.window[data-maxed="1"]').forEach(w => {
      w.style.left = insetX + 'px';
      w.style.top = insetY + 'px';
      w.style.width = width + 'px';
      w.style.height = height + 'px';
      // Maintain no-elevate so we don't nudge while resizing to top edge
      w.classList.add('no-elevate');
      // Add a subtle frame switch animation
      w.classList.remove('frame-switch');
      void w.offsetWidth; // reflow to restart animation
      w.classList.add('frame-switch');
      setTimeout(() => { try { w.classList.remove('frame-switch'); } catch(_) {} }, 280);
    });
  } catch(_) {}
}

// Keep centered layout consistent on viewport resize
let _tbResizeTimer = null;
window.addEventListener('resize', () => {
  if (_tbResizeTimer) cancelAnimationFrame(_tbResizeTimer);
  _tbResizeTimer = requestAnimationFrame(() => applyTaskbarStyle(false));
});

// Theming removed: OS runs in dark-only mode

// Boot sequence (BIOS-like pre-OS screen)
const boot = document.getElementById("boot"), progress = document.getElementById("progress");
let booted = false;
function runBoot() {
  // If a restart requested to skip BIOS, go straight to desktop loader
  try {
    if (sessionStorage.getItem('rtos.skipBios') === '1') {
      sessionStorage.removeItem('rtos.skipBios');
      // Ensure any BIOS overlay is not present
      const ov = document.getElementById('biosOverlay');
      if (ov) ov.remove();
      // Show loader UI directly
      const boot = document.getElementById('boot');
      if (boot) boot.classList.remove('hidden');
      // Fast path into finishBoot via the normal loader
      setTimeout(() => {
        try { finishBoot(); } catch(_) {}
      }, 400);
      return;
    }
  } catch(_) {}
  // Hide the default boot UI while BIOS screen shows
  try { if (boot) boot.style.display = 'none'; } catch(_) {}

  // Create BIOS-like overlay
  const existing = document.getElementById('biosOverlay');
  if (existing) existing.remove();
  const overlay = document.createElement('div');
  overlay.id = 'biosOverlay';
  overlay.style.cssText = 'position:fixed;inset:0;background:#000;color:#fff;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;font-size:14px;line-height:1.35;display:flex;flex-direction:column;justify-content:flex-start;padding:0;z-index:100000;';

  // Header
  const header = document.createElement('div');
  header.style.cssText = 'padding:14px 18px 10px 18px;border-bottom:1px solid rgba(255,255,255,0.08)';
  const title = document.createElement('div');
  title.style.cssText = 'font-weight:800;font-size:16px;letter-spacing:.2px';
  title.textContent = 'RT Firmware v2.1.x';
  const sub = document.createElement('div');
  sub.style.cssText = 'color:#9aa0a6;font-size:12px;margin-top:2px';
  try { sub.textContent = `RT Systems | Build Date: ${new Date().toLocaleDateString()}`; } catch(_) { sub.textContent = 'RT Systems'; }
  header.appendChild(title);
  header.appendChild(sub);

  const contentWrap = document.createElement('div');
  contentWrap.style.cssText = 'flex:1;display:flex;flex-direction:column;justify-content:space-between;padding:18px;';

  const top = document.createElement('div');
  const bottom = document.createElement('div');
  bottom.style.cssText = 'display:flex;align-items:center;gap:8px;color:#cfcfcf;min-height:22px';

  // Top-right quick hints like BIOS
  const hints = document.createElement('div');
  hints.style.cssText = 'position:absolute;top:10px;right:12px;color:#bbb;font-size:12px;text-align:right;opacity:.85';
  hints.innerHTML = 'Press F2 for Setup\nPress F12 for Boot Menu';
  overlay.appendChild(hints);

  const log = document.createElement('div');
  log.setAttribute('aria-live', 'polite');
  function appendLine(t) {
    const d = document.createElement('div');
    d.textContent = t;
    top.appendChild(d);
  }

  // Spinner + dots status (Windows-like vibe)
  const spFrames = ['⠋','⠙','⠹','⠸','⠼','⠴','⠦','⠧','⠇','⠏'];
  let spIdx = 0, dot = 0, statusTimer = null;
  const statusText = document.createElement('div');
  statusText.style.cssText = 'color:#dddddd';
  function startStatus(label) {
    statusTimer = setInterval(() => {
      spIdx = (spIdx + 1) % spFrames.length;
      dot = (dot + 1) % 6;
      statusText.textContent = `${spFrames[spIdx]} ${label}${'.'.repeat(dot)}`;
    }, 120);
  }
  function stopStatus() { if (statusTimer) { clearInterval(statusTimer); statusTimer = null; } }

  bottom.appendChild(statusText);
  contentWrap.appendChild(top);
  contentWrap.appendChild(bottom);
  overlay.appendChild(header);
  overlay.appendChild(contentWrap);

  // Footer separator with hints text (bottom bar)
  const footer = document.createElement('div');
  footer.style.cssText = 'border-top:1px solid rgba(255,255,255,0.08);padding:8px 18px;color:#9aa0a6;font-size:12px;display:flex;align-items:center;';
  footer.textContent = 'RT Systems | Press F2 for Setup, F12 for Boot Menu';
  overlay.appendChild(footer);
  document.body.appendChild(overlay);

  // BIOS info (generic, no brand names)
  const biosLines = [
    'Generic Firmware Interface v1.0',
    'Copyright (C) Generic Systems',
    '',
    'CPU: 4-Core 64-bit Processor @ 2.40 GHz',
    'Memory: 8192 MB OK',
    'Storage 0: Solid State Device - 512 GB',
    'Storage 1: Removable USB Device - 16 GB',
    'Video: Generic graphical device',
    'Network: Generic Ethernet Controller - Connected',
    '',
    'Detecting bootable volumes...',
    'Selecting primary boot volume...',
    'Preparing to start operating system'
  ];

  // Show BIOS lines over ~16.8s (21 lines * 0.8s)
  let i = 0;
  function showNext() {
    if (booted) return;
    if (i < biosLines.length) {
      appendLine(biosLines[i++]);
      setTimeout(showNext, 800);
    } else {
      // Transition to OS loader with spinner + dots (~6s)
      appendLine('');
      startStatus('Loading operating system');
      setTimeout(() => {
        stopStatus();
        // Intermediate handover: full-black screen with top blinking dot
        overlay.remove();
        const handover = document.createElement('div');
        handover.style.cssText = 'position:fixed;inset:0;background:#000;z-index:100000;display:block;';
        const dot = document.createElement('div');
        dot.textContent = '-';
        dot.style.cssText = 'position:absolute;top:16px;left:16px;font-family:ui-monospace, Menlo, Consolas, monospace;font-size:16px;line-height:1;color:#fff;opacity:0;';
        handover.appendChild(dot);
        document.body.appendChild(handover);
        let vis = false; const blink = setInterval(() => { vis = !vis; dot.style.opacity = vis ? '1' : '0'; }, 250);
        setTimeout(() => {
          clearInterval(blink);
          // Reveal original boot UI with slide-up animation
          try {
            if (boot) {
              boot.style.display = '';
              boot.style.transition = 'transform 600ms cubic-bezier(0.22, 1, 0.36, 1), opacity 600ms ease';
              boot.style.transform = 'translateY(40px)';
              boot.style.opacity = '0';
              // Force reflow
              void boot.offsetHeight;
              boot.style.transform = 'translateY(0)';
              boot.style.opacity = '1';
            }
          } catch(_) {}
          handover.remove();
          // Phase 2: original initializing progress
          let p = 0;
          const statusEl = document.getElementById('bootStatus');
          const pctEl = document.getElementById('bootPct');
          // Build a persistent spinner so it doesn't reset on text updates
          let msgSpan = null;
          if (statusEl) {
            statusEl.innerHTML = '';
            const spinEl = document.createElement('span');
            spinEl.className = 'boot-spinner';
            msgSpan = document.createElement('span');
            statusEl.appendChild(spinEl);
            statusEl.appendChild(document.createTextNode(' '));
            statusEl.appendChild(msgSpan);
          }
          const messages = [
            'Initializing system modules…',
            'Starting kernel services…',
            'Mounting user space…',
            'Launching window manager…',
            'Loading desktop and apps…'
          ];
          const steps = [1400, 1400, 1200, 1200]; // ~5.2s total
          function step(j) {
            if (booted) return;
            if (j >= steps.length) {
              // Ensure UI reaches 100% and linger a touch before desktop
              p = 100;
              if (progress) progress.style.width = '100%';
              if (pctEl) pctEl.textContent = '100%';
              if (msgSpan) msgSpan.textContent = 'Finalizing…'; else if (statusEl) statusEl.textContent = 'Finalizing…';
              setTimeout(() => { if (!booted) finishBoot(); }, 800);
              return;
            }
            p += Math.round(100/steps.length);
            if (p > 98) p = 98;
            if (progress) progress.style.width = p + '%';
            if (msgSpan) msgSpan.textContent = messages[j] || 'Loading…';
            if (pctEl) pctEl.textContent = p + '%';
            setTimeout(() => step(j+1), steps[j]);
          }
          if (msgSpan) msgSpan.textContent = messages[0];
          if (pctEl) pctEl.textContent = '0%';
          setTimeout(() => step(0), 100);
        }, 1500);
      }, 6000);
    }
    // Autohide behavior setup
    try {
      setupTaskbarAutohide();
    } catch(_) {}
  }
  setTimeout(showNext, 400);
}
runBoot();

  // Centered-mode Taskbar Autohide
  let __tbHoverZone = null, __tbHideTimer = null, __tbShowLock = false, __tbLastInteract = 0;
  function setupTaskbarAutohide() {
    const tb = document.getElementById('taskbar');
    if (!tb) return;
    const active = tb.classList.contains('centered') && tb.classList.contains('autohide');
    // Only use wrapper in centered+autohide mode; keep non-centered as fixed separate bar
    let dw = tb.parentElement && tb.parentElement.classList && tb.parentElement.classList.contains('dock-wrap') ? tb.parentElement : null;
    if (active) {
      if (!dw) {
        const wrap = document.createElement('div');
        wrap.className = 'dock-wrap';
        // keep autohide flag in sync for CSS
        wrap.classList.add('autohide');
        // Reparent without visibility flicker
        const parent = tb.parentNode;
        if (parent) {
          parent.insertBefore(wrap, tb);
          wrap.appendChild(tb);
        }
        dw = wrap;
      } else {
        // ensure wrapper has autohide class
        dw.classList.add('autohide');
      }
    } else if (dw) {
      // unwrap if we are not in centered autohide mode
      dw.classList.remove('hidden');
      if (dw.parentNode) {
        dw.parentNode.insertBefore(tb, dw);
        dw.remove();
      }
      dw = null;
    }
    const hasAnyVisibleWindow = () => {
      const wins = Array.from(document.querySelectorAll('.window'));
      return wins.some(w => {
        // Exclude closing windows
        if (w.hasAttribute('data-closing')) return false;
        const st = getComputedStyle(w);
        return st.display !== 'none' && st.visibility !== 'hidden' && w.offsetParent !== null;
      });
    };
    const getOverlays = () => ({
      startMenu: document.getElementById('startMenu'),
      searchResults: document.getElementById('searchResults'),
      wifiPanel: (typeof wifiPanelEl !== 'undefined' && wifiPanelEl) ? wifiPanelEl : document.querySelector('.wifi-panel')
    });
    const markInteract = () => { __tbLastInteract = Date.now(); };
    const isVisible = (el) => {
      if (!el) return false;
      const style = getComputedStyle(el);
      // offsetParent is null for position: fixed elements even when visible,
      // so rely on computed style + bounding rect and DOM containment.
      if (style.display === 'none' || style.visibility === 'hidden' || parseFloat(style.opacity || '1') === 0) return false;
      const rect = el.getBoundingClientRect();
      const hasBox = rect.width > 0 && rect.height > 0;
      const inDoc = document.documentElement.contains(el);
      return inDoc && hasBox;
    };

  // Slide the whole dock by toggling wrapper visibility (transform transition only)
  const setDockHidden = (hidden) => {
    if (!tb.classList.contains('autohide')) return;
    if (!dw) return;
    const isHidden = dw.classList.contains('hidden');
    if (hidden === isHidden) return;
    clearTimeout(__tbHideTimer); __tbHideTimer = null;
    // Ensure transition runs even if toggled rapidly
    void dw.offsetHeight;
    if (hidden) {
      dw.classList.add('hidden');
    } else {
      dw.classList.remove('hidden');
    }
  };
  // Ensure hover zone exists only when needed
  if (!active || !hasAnyVisibleWindow()) {
    if (__tbHoverZone && __tbHoverZone.parentNode) __tbHoverZone.parentNode.removeChild(__tbHoverZone);
    __tbHoverZone = null;
    setDockHidden(false);
    clearTimeout(__tbHideTimer); __tbHideTimer = null;
    return;
  }
  if (!__tbHoverZone) {
    const zone = document.createElement('div');
    zone.id = 'tbHoverZone';
    Object.assign(zone.style, {
      position:'fixed', left:'0', right:'0', bottom:'0', height:'36px',
      zIndex:'89999', // above windows (<=89998), below taskbar (90000)
      pointerEvents:'auto', background:'transparent'
    });
    document.body.appendChild(zone);
    __tbHoverZone = zone;
  }
  const updateMaximizedWindowsForTaskbarVisibility = () => {
    // In overlay mode, do NOT shrink maximized windows when the taskbar shows.
    const insetY = 0, insetX = 0;
    const width = Math.max(200, window.innerWidth - insetX*2);
    const fullH = Math.max(160, Math.round(window.innerHeight - insetY));
    document.querySelectorAll('.window[data-maxed="1"]').forEach(w => {
      w.style.left = insetX + 'px';
      w.style.top = insetY + 'px';
      w.style.width = width + 'px';
      w.style.height = fullH + 'px';
    });
  };

  const show = () => {
    if (!tb.classList.contains('autohide')) return;
    if (!hasAnyVisibleWindow()) { setDockHidden(false); return; }
    setDockHidden(false);
    clearTimeout(__tbHideTimer); __tbHideTimer = null;
    // Auto-hide again after a short idle (2.5s)
    scheduleHide(2500);
    // Do not resize maximized windows; taskbar overlays them
  };
  const scheduleHide = (delay=2500) => {
    if (!tb.classList.contains('autohide')) return;
    clearTimeout(__tbHideTimer);
    __tbHideTimer = setTimeout(() => {
      // Do not hide while hovering taskbar or interacting with search/results
      const overTb = tb.matches(':hover');
      const { startMenu, searchResults, wifiPanel } = getOverlays();
      const startOpen = !!(startMenu && (startMenu.classList.contains('show') || isVisible(startMenu)));
      const searchOpen = !!(searchResults && isVisible(searchResults));
      const wifiOpen = !!(wifiPanel && isVisible(wifiPanel));
      const focusedInside = !!(document.activeElement && (tb.contains(document.activeElement) || (startMenu && startMenu.contains(document.activeElement)) || (searchResults && searchResults.contains(document.activeElement)) || (wifiPanel && wifiPanel.contains(document.activeElement))));
      const interacting = overTb || startOpen || searchOpen || wifiOpen || focusedInside;
      if (interacting) { markInteract(); scheduleHide(800); return; }
      // Short grace after last interaction (~2.2s)
      const since = Date.now() - __tbLastInteract;
      if (since < 2200) { scheduleHide(2200 - since); return; }
      if (!hasAnyVisibleWindow()) { setDockHidden(false); return; }
      setDockHidden(true);
      // No window resize here either; windows remain full height
    }, delay);
  };
  __tbHoverZone.onmouseenter = () => { markInteract(); show(); };
  __tbHoverZone.onmouseleave = () => { markInteract(); scheduleHide(360); };
  tb.onmouseenter = () => { markInteract(); show(); clearTimeout(__tbHideTimer); };
  tb.onmouseleave = () => { markInteract(); scheduleHide(300); };
  // Nudge: when pointer is near bottom, reveal
  window.addEventListener('mousemove', (e) => {
    if (!tb.classList.contains('autohide')) return;
    if (e.clientY >= window.innerHeight - 36) { markInteract(); show(); }
  });
  // Initial hide on idle after a short delay
  markInteract();
  scheduleHide(2500);

  // Track interactions on overlays to extend grace period
  const { startMenu, searchResults, wifiPanel } = getOverlays();
  const watch = (el) => {
    if (!el) return;
    ['pointerdown','pointermove','mousemove','wheel','keydown','focusin','touchstart'].forEach(ev => el.addEventListener(ev, markInteract, { passive: true }));
  };
  watch(tb);
  watch(startMenu);
  watch(searchResults);
  watch(wifiPanel);
  // Recompute on resize
  window.addEventListener('resize', () => {
    if (!tb.classList.contains('autohide')) return;
    updateMaximizedWindowsForTaskbarVisibility();
  });
}

// Attempt to play the boot chime; if blocked, wait for first user interaction
// Developer shortcut: Shift + D to skip BIOS/boot and enter desktop immediately
window.addEventListener('keydown', (e) => {
  try {
    if ((e.key === 'D' || e.key === 'd') && e.shiftKey) {
      e.preventDefault();
      const ov = document.getElementById('biosOverlay');
      if (ov) ov.remove();
      finishBoot();
    }
  } catch(_) {}
}, { capture: true });

function playBootChime() {
  const audio = document.getElementById('bootChime');
  if (!audio) return;
  audio.currentTime = 0;
  audio.volume = 0.7;
  const tryPlay = () => audio.play().catch((err) => {
    // Autoplay likely blocked; wait for a one-time user gesture
    const resume = () => {
      audio.play().catch(()=>{});
      window.removeEventListener('pointerdown', resume, { once: true });
      window.removeEventListener('keydown', resume, { once: true });
    };
    window.addEventListener('pointerdown', resume, { once: true });
    window.addEventListener('keydown', resume, { once: true });
  });
  tryPlay();
}

// Shutdown sequence with chime and reboot prompt
function playShutdownAndExit() {
  // Grab audio before UI changes
  const audio = document.getElementById('shutdownChime');

  // Shutting down overlay (styled)
  const overlay = document.createElement('div');
  overlay.id = 'shutdownOverlay';
  overlay.className = 'shutdown-screen';
  overlay.innerHTML = `
    <div class="shutdown-card white-corners-strong">
      <div class="shutdown-title">Power</div>
      <div class="shutdown-sub"><span class="shutdown-spinner"></span>Shutting down…</div>
      <div style="color:var(--muted);font-size:13px;">Please wait while RT OS closes apps and saves state.</div>
    </div>
  `;
  document.body.appendChild(overlay);

  // After chime, switch to reboot prompt
  const showPowerOnPrompt = () => {
    overlay.className = 'shutdown-screen off';
    overlay.innerHTML = `
      <div class="shutdown-card white-corners-strong" role="dialog" aria-label="Power on">
        <div class="shutdown-title">RT OS</div>
        <div class="shutdown-sub">Press and hold power to turn back on</div>
        <div id="powerOnBtn" class="power-on-btn" role="button" aria-label="Hold to power on" tabindex="0">
          <div class="hold-ring" id="holdRing"></div>
          <div class="power-on-glyph">⏻</div>
        </div>
        <div class="shutdown-sub" style="margin-top:12px;opacity:.85">Hold 1.5s to power on</div>
      </div>`;

    const btn = overlay.querySelector('#powerOnBtn');
    const ring = overlay.querySelector('#holdRing');
    let holdTimer = null;

    const startHold = () => {
      if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
      ring.style.transform = 'scale(1)';
      holdTimer = setTimeout(() => { location.reload(); }, 1500);
    };
    const cancelHold = () => {
      if (holdTimer) { clearTimeout(holdTimer); holdTimer = null; }
      ring.style.transform = 'scale(0)';
    };

    btn.addEventListener('pointerdown', (e) => { e.preventDefault(); startHold(); });
    btn.addEventListener('pointerup', cancelHold);
    btn.addEventListener('pointercancel', cancelHold);
    btn.addEventListener('pointerleave', cancelHold);
    btn.addEventListener('keydown', (e) => { if (e.code === 'Space' || e.code === 'Enter') startHold(); });
    btn.addEventListener('keyup', (e) => { if (e.code === 'Space' || e.code === 'Enter') cancelHold(); });
  };

  if (!audio) { setTimeout(showPowerOnPrompt, 1200); return; }

  try {
    audio.currentTime = 0;
    audio.volume = 0.9;
    const playPromise = audio.play();
    if (playPromise && typeof playPromise.then === 'function') {
      playPromise.then(() => {
        let ended = false;
        const safety = setTimeout(() => { if (!ended) showPowerOnPrompt(); }, Math.min(15000, ((audio.duration || 2.5) * 1000) + 300));
        audio.onended = () => { ended = true; clearTimeout(safety); showPowerOnPrompt(); };
      }).catch(() => setTimeout(showPowerOnPrompt, 1200));
    } else {
      setTimeout(showPowerOnPrompt, Math.min(15000, ((audio.duration || 2.5) * 1000) + 300));
    }
  } catch (e) {
    setTimeout(showPowerOnPrompt, 1200);
  }
}

function finishBoot() {
  if (booted) return;
  booted = true;
  progress.style.width = "100%";
  const pctEl = document.getElementById('bootPct');
  if (pctEl) pctEl.textContent = '100%';
  setTimeout(() => {
    boot.classList.add("hidden");
    setTimeout(() => {
      boot.style.display = "none";
      
      const di = document.getElementById('desktopInner');
      // Build icons before revealing the desktop to avoid pre-animation flash
      renderDesktopIcons();
      // Stagger icons
      document.querySelectorAll('#desktopIcons .icon').forEach((icon, index) => {
        icon.style.animationDelay = `${index * 0.08}s`;
      });
      // Stagger taskbar app chips
      document.querySelectorAll('.taskbar .task-mid > *').forEach((el, idx) => {
        el.style.animationDelay = `${0.15 + idx * 0.05}s`;
      });
      // Add class to activate CSS animations
      document.body.classList.add('boot-reveal');
      try { const tb = document.getElementById('taskbar'); if (tb) tb.classList.remove('preboot-hidden'); } catch(_) {}
      di.classList.add('desktop-appear');
      di.style.opacity = '1';
      updateStartMenu();
      // Play boot chime when we reach the desktop
      playBootChime();
    }, 800);
  }, 350);
}

// Time and date display
function updateTime() {
  const el = document.getElementById("timeDisplay");
  if (!el) return;
  const now = new Date();
  const timeStr = now.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit"});
  const dateStr = now.toLocaleDateString([], {weekday:'short', month:'short', day:'numeric'});
  el.innerText = `${dateStr} • ${timeStr}`;
}
updateTime();
setInterval(updateTime, 1000);

// ----------------------
// Wi‑Fi indicator + API
// ----------------------
function renderWifiIndicator() {
  const el = document.getElementById('wifiIndicator');
  if (!el) return;
  const connected = !!(state.wifi && state.wifi.connected);
  const connecting = !!(state.wifi && state.wifi.connecting);
  const netId = state.wifi && (connecting ? state.wifi.target : state.wifi.network);
  const profile = netId ? state.wifiNetworks[netId] : null;
  const level = profile && typeof profile.strength === 'number' ? Math.max(0, Math.min(4, profile.strength)) : 0;
  const colorOn = 'rgba(255,255,255,1)';
  const colorOff = 'rgba(255,255,255,0.35)';
  const colorConn = 'rgba(255,255,255,0.8)';
  // Use global wifiBarsIcon; show slash when fully disconnected
  const iconSvg = connected
    ? wifiBarsIcon(level, colorOn, colorOff)
    : (connecting
        ? wifiBarsIcon(level || 2, colorConn, colorOff)
        : wifiBarsIcon(0, colorOff, colorOff, 'xcut'));
  el.innerHTML = iconSvg;
  el.title = connecting
    ? `Wi‑Fi: Connecting${profile? ' to '+profile.ssid : ''}...`
    : (connected ? `Wi‑Fi: ${profile? profile.ssid : 'Connected'}` : 'Wi‑Fi: Not connected');
}

// Keep quick Wi‑Fi panel in sync while connecting or after changes
try {
  document.addEventListener('wifi-changed', () => {
    if (wifiPanelEl && typeof wifiPanelEl._updateWifiPanel === 'function') {
      wifiPanelEl._updateWifiPanel();
    }
  });
} catch(_) {}

// Render indicator on load so desktop shows initial state
try { renderWifiIndicator(); } catch(_) {}

function setWifi(networkId) {
  // Immediate switch (internal use)
  if (!networkId) {
    state.wifi.connected = false;
    state.wifi.network = null;
    state.wifi.connecting = false;
    state.wifi.target = null;
  } else {
    state.wifi.connected = true;
    state.wifi.network = networkId;
    state.wifi.connecting = false;
    state.wifi.target = null;
  }
  renderWifiIndicator();
  try { document.dispatchEvent(new CustomEvent('wifi-changed', { detail: { ...state.wifi } })); } catch(_) {}
}

let wifiConnTicker = null;
function connectWifi(networkId) {
  // Simulate fixed 10s connecting delay with countdown
  state.wifi.connected = false;
  state.wifi.network = null;
  state.wifi.connecting = true;
  state.wifi.target = networkId;
  state.wifi.connectEndAt = Date.now() + 10000;
  renderWifiIndicator();
  try { document.dispatchEvent(new CustomEvent('wifi-changed', { detail: { ...state.wifi } })); } catch(_) {}
  const delay = 10000; // 10s
  if (wifiConnTicker) { clearInterval(wifiConnTicker); wifiConnTicker = null; }
  wifiConnTicker = setInterval(() => {
    renderWifiIndicator();
    try { document.dispatchEvent(new CustomEvent('wifi-changed', { detail: { ...state.wifi } })); } catch(_) {}
  }, 1000);
  setTimeout(() => {
    // If not cancelled meanwhile
    if (state.wifi.connecting && state.wifi.target === networkId) {
      state.wifi.connected = true;
      state.wifi.network = networkId;
      state.wifi.connecting = false;
      state.wifi.target = null;
      state.wifi.connectEndAt = null;
      renderWifiIndicator();
      try { document.dispatchEvent(new CustomEvent('wifi-changed', { detail: { ...state.wifi } })); } catch(_) {}
    }
    if (wifiConnTicker) { clearInterval(wifiConnTicker); wifiConnTicker = null; }
  }, delay);
}

function disconnectWifi() {
  state.wifi.connected = false;
  state.wifi.network = null;
  state.wifi.connecting = false;
  state.wifi.target = null;
  state.wifi.connectEndAt = null;
  if (wifiConnTicker) { clearInterval(wifiConnTicker); wifiConnTicker = null; }
  renderWifiIndicator();
  try { document.dispatchEvent(new CustomEvent('wifi-changed', { detail: { ...state.wifi } })); } catch(_) {}
}

// Quick Wi‑Fi panel UI
let wifiPanelEl = null;
function closeWifiPanel(){ if(wifiPanelEl){ wifiPanelEl.remove(); wifiPanelEl=null; document.removeEventListener('click', handleWifiOutside, false);} }
function handleWifiOutside(e){ if(wifiPanelEl && !wifiPanelEl.contains(e.target) && !e.target.closest('#wifiIndicator')) closeWifiPanel(); }
function strengthToBars(str){ return Math.max(1, Math.min(3, Number(str)||1)); }
function wifiStdIcon(color){
  const s = 2;
  return `
  <svg viewBox="0 0 24 24" width="24" height="24" style="shape-rendering:crispEdges" aria-hidden="true">
    <path d="M3 9a9 9 0 0 1 18 0" fill="none" stroke="${color}" stroke-width="${s}" vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M6 12a6 6 0 0 1 12 0" fill="none" stroke="${color}" stroke-width="${s}" vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round"/>
    <path d="M9 15a3 3 0 0 1 6 0" fill="none" stroke="${color}" stroke-width="${s}" vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round"/>
    <circle cx="12" cy="18" r="1.4" fill="${color}"/>
  </svg>`;
}
function wifiBarsIcon(level,colorOn='rgba(255,255,255,1)',colorOff='rgba(255,255,255,0.35)', slash='none'){
  const lvl = Math.max(0, Math.min(4, Number(level)||0));
  const act = (i)=> i<=lvl ? colorOn : colorOff;
  return `
    <svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" focusable="false">
      <rect x="3" y="18" width="3" height="3" rx="1.5" ry="1.5" fill="${act(1)}"/>
      <rect x="8" y="15" width="3" height="6" rx="1.5" ry="1.5" fill="${act(2)}"/>
      <rect x="13" y="12" width="3" height="9" rx="1.5" ry="1.5" fill="${act(3)}"/>
      <rect x="18" y="8" width="3" height="13" rx="1.5" ry="1.5" fill="${act(4)}"/>
      ${slash==='diagonal' ? '<path d="M4 20 L20 4" stroke="rgba(255,255,255,0.85)" stroke-width="2" stroke-linecap="butt" />' : ''}
      ${slash==='strike' ? '<path d="M4 12 H20" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="butt" />' : ''}
      ${slash==='xcut' ? '<path d="M7 7 L17 17" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="butt" /><path d="M7 17 L17 7" stroke="rgba(255,255,255,0.9)" stroke-width="2" stroke-linecap="butt" />' : ''}
    </svg>`;
}
function strengthDots(n){
  const v = Math.max(0, Math.min(4, Number(n)||0));
  const dot = (on)=>`<span class="sig-dot${on? ' active':''}"></span>`;
  return `<span class="sig-dots">${dot(v>=1)}${dot(v>=2)}${dot(v>=3)}${dot(v>=4)}</span>`;
}
function renderWifiPanel(){
  closeWifiPanel();
  const panel = document.createElement('div');
  panel.className = 'wifi-panel white-corners page-enter';
  const header = document.createElement('div');
  header.className = 'wifi-header';
  const list = document.createElement('div');
  list.className = 'wifi-list';

  const updateContents = () => {
    const connected = !!(state.wifi && state.wifi.connected);
    const connecting = !!(state.wifi && state.wifi.connecting);
    const netId = state.wifi && (connecting ? state.wifi.target : state.wifi.network);
    const profile = netId ? state.wifiNetworks[netId] : null;
    const level = profile && typeof profile.strength === 'number' ? Math.max(0, Math.min(4, profile.strength)) : 0;
    const hdrIcon = connected ? wifiBarsIcon(level) : (connecting ? wifiBarsIcon(level || 2, 'rgba(255,255,255,0.9)') : wifiBarsIcon(0, 'rgba(255,255,255,0.35)', 'rgba(255,255,255,0.25)', 'xcut'));
    header.innerHTML = `<div class="wifi-icon">${hdrIcon}</div><div class="wifi-title">Wi‑Fi</div><div class="wifi-right"><button class="btn-ghost" id="btnWifiSettings">Settings</button></div>`;
    const btn = header.querySelector('#btnWifiSettings');
    if (btn) btn.onclick = ()=>{ closeWifiPanel(); openApp('settings', { section: 'network' }); };

    list.innerHTML = '';
    Object.entries(state.wifiNetworks).forEach(([id, net])=>{
      const row = document.createElement('div');
      row.className = 'wifi-net';
      const isCurrent = state.wifi.connected && state.wifi.network === id;
      const isConnecting = state.wifi.connecting && state.wifi.target === id;
      const color = isCurrent ? '#fff' : (isConnecting ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.7)');
      const bars = wifiBarsIcon(net.strength || 0, color, 'rgba(255,255,255,0.25)');
      const pillBase = 'display:inline-flex;align-items:center;gap:6px;height:28px;padding:6px 10px;border-radius:14px;box-sizing:border-box;font-weight:600;font-size:12px;line-height:16px;';
      const pillAction = `${pillBase}background:transparent;border:1px solid rgba(255,255,255,0.22);color:rgba(255,255,255,0.95);justify-content:center;`;
      const pillConnecting = `${pillBase}background:transparent;border:1px solid rgba(255,255,255,0.22);color:rgba(255,255,255,0.95);justify-content:center;`;
      const pillOk = `${pillBase}background:transparent;border:1px solid rgba(255,255,255,0.22);color:rgba(255,255,255,0.95);justify-content:center;`;
      const rightBoxStyle = 'min-width:132px;display:flex;justify-content:flex-end;';
      const noWifiIcon = `<span style="display:inline-flex;transform:scale(0.75);transform-origin:left center;">${wifiBarsIcon(0,'rgba(255,255,255,0.95)','rgba(255,255,255,0.25)','xcut')}</span>`;
      row.innerHTML = `<div class=\"wifi-icon\">${bars}</div>
        <div>
          <div style=\"font-weight:700\">${net.ssid}</div>
          <div style=\"color:var(--muted);font-size:12px;display:flex;align-items:center;gap:8px\">
            <span>${isConnecting ? 'Connecting…' : (isCurrent ? 'Connected' : 'Available')}</span>
          </div>
        </div>
        <div class=\"wifi-right\" style=\"${rightBoxStyle}\">${isCurrent
          ? `<span class=\"wifi-pill\" style=\"${pillOk}\">Connected</span>`
          : (isConnecting
              ? `<span class=\"wifi-pill\" style=\"${pillConnecting}\">${noWifiIcon}<span>Connecting…</span></span>`
              : `<button class=\"wifi-pill\" style=\"${pillAction}\">Connect</button>`)}
        </div>`;
      row.addEventListener('click', (e)=>{
        const wasBtn = e.target.closest('button');
        if(isCurrent){ disconnectWifi(); }
        else if (isConnecting) {
          // Cancel connecting
          disconnectWifi();
        } else {
          if (!state.wifi.connecting || state.wifi.target !== id) {
            connectWifi(id);
          }
        }
        if (wifiPanelEl && typeof wifiPanelEl._updateWifiPanel === 'function') {
          wifiPanelEl._updateWifiPanel();
        }
        e.stopPropagation();
      });
      list.appendChild(row);
    });
  };

  panel.appendChild(header); panel.appendChild(list);
  document.body.appendChild(panel);
  setTimeout(()=>{  document.addEventListener('click', handleWifiOutside, false); }, 0);
  wifiPanelEl = panel;
  updateContents();
  panel._updateWifiPanel = updateContents;
  // Position panel near Wi‑Fi indicator (especially for centered dock)
  try {
    const anchor = document.getElementById('wifiIndicator');
    if (anchor) {
      const ar = anchor.getBoundingClientRect();
      const pr = panel.getBoundingClientRect();
      // Place above taskbar; ensure no overlap with dock in either mode
      const tbEl = document.getElementById('taskbar');
      const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
      const tbH = tbEl ? Math.round(tbEl.getBoundingClientRect().height) : 0;
      const dockOffset = centeredAuto ? 10 : 0; // matches CSS bottom for centered.autohide
      const minBottom = Math.max(8, tbH + dockOffset + 8);
      const nearAnchor = Math.max(8, window.innerHeight - ar.top + 10);
      const bottom = Math.max(minBottom, nearAnchor);
      panel.style.bottom = bottom + 'px';
      // Align right edge of panel with right edge of Wi‑Fi button, minimal clamp
      let desiredLeft = Math.round(ar.right - pr.width);
      desiredLeft = Math.min(Math.max(4, desiredLeft), window.innerWidth - pr.width - 4);
      panel.style.left = desiredLeft + 'px';
      panel.style.right = 'auto';
    }
  } catch(_) {}
}

// Init Wi‑Fi indicator and click behavior -> open quick panel
setTimeout(() => {
  renderWifiIndicator();
  const el = document.getElementById('wifiIndicator');
  if (el) {
    const toggle = () => { if (wifiPanelEl) closeWifiPanel(); else renderWifiPanel(); };
    el.addEventListener('click', toggle);
    el.addEventListener('keydown', (e) => { if (e.key==='Enter' || e.key===' ') { e.preventDefault(); toggle(); }});
  }
  // Hook compact search expand/collapse
  const searchEl = document.getElementById('taskbarSearch');
  const searchBtn = document.getElementById('taskbarSearchBtn');
  if (searchEl) {
    const update = () => {
      if (typeof __searchInteracting !== 'undefined' && __searchInteracting) return;
      const tb = document.getElementById('taskbar');
      const centered = tb && tb.classList.contains('centered');
      if (!centered) {
        // Full-width mode: never keep stale text when not focused
        if (document.activeElement !== searchEl && !(typeof __searchInteracting !== 'undefined' && __searchInteracting)) {
          try { searchEl.value = ''; if (typeof hideSearch === 'function') hideSearch(true); } catch(_) {}
        }
        searchEl.classList.remove('expanded');
        searchEl.placeholder = 'Search RT OS, apps or web...';
        return;
      }
      if (document.activeElement === searchEl) {
        searchEl.classList.add('expanded');
        searchEl.placeholder = 'Search RT OS, apps or web...';
      } else {
        searchEl.classList.remove('expanded');
        searchEl.placeholder = 'Search';
        if (!(typeof __searchInteracting !== 'undefined' && __searchInteracting)) {
          try { searchEl.value = ''; if (typeof hideSearch === 'function') hideSearch(true); } catch(_) {}
        }
      }
    };
    searchEl.addEventListener('focus', update);
    searchEl.addEventListener('input', update);
    searchEl.addEventListener('blur', () => {
      if (typeof __searchInteracting !== 'undefined' && __searchInteracting) { setTimeout(()=>update(), 0); return; }
      const tb = document.getElementById('taskbar');
      const centered = tb && tb.classList.contains('centered');
      // Always clear value and hide results on blur
      try { searchEl.value = ''; if (typeof hideSearch === 'function') hideSearch(true); } catch(_) {}
      if (centered) {
        searchEl.classList.remove('expanded');
        searchEl.placeholder = 'Search';
      } else {
        searchEl.placeholder = 'Search RT OS, apps or web...';
      }
    });
    searchEl.addEventListener('keydown', (e)=>{
      if (e.key === 'Escape') {
        try { searchEl.value = ''; if (typeof hideSearch === 'function') hideSearch(true); } catch(_) {}
        searchEl.classList.remove('expanded'); searchEl.blur(); update();
      }
    });
    if (searchBtn) {
      const open = () => {
        // Expand compact input and show the full search chrome like non-centered mode
        searchEl.classList.add('expanded');
        try { if (typeof renderSearchChrome === 'function') renderSearchChrome(); } catch(_) {}
        if (searchResults) {
          searchResults.style.display = 'block';
          try { if (typeof positionSearchResults === 'function') positionSearchResults(); } catch(_) {}
        }
        searchEl.focus();
        update();
      };
      searchBtn.addEventListener('click', (e)=>{ e.stopPropagation(); open(); });
      searchBtn.addEventListener('keydown', (e)=>{ if (e.key==='Enter' || e.key===' ') { e.preventDefault(); open(); }});
    }
    update();
  }
}, 0);

// In-OS Power confirmation dialog
function openPowerDialog() {
  const existing = document.getElementById('powerOverlay');
  if (existing) existing.remove();

  const ov = document.createElement('div');
  ov.id = 'powerOverlay';
  ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.45);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;z-index:100000;';

  const dlg = document.createElement('div');
  dlg.className = 'white-corners';
  dlg.style.cssText = 'width:360px;background:rgba(20,22,25,0.92);padding:20px;border-radius:18px;box-shadow:0 20px 48px rgba(0,0,0,0.7);';
  dlg.innerHTML = `
    <div style="font-weight:800;font-size:18px;margin-bottom:8px;">Power</div>
    <div style="color:var(--muted);margin-bottom:18px;font-size:14px;">Are you sure you would like to shut down the OS?</div>
    <div style="display:flex;gap:10px;justify-content:flex-end;">
      <button id="btnCancelShutdown" class="btn">Cancel</button>
      <button id="btnConfirmShutdown" class="btn" style="background:rgba(255,255,255,0.14);">Shut down</button>
    </div>
  `;

  ov.appendChild(dlg);
  document.body.appendChild(ov);

  document.getElementById('btnCancelShutdown').onclick = () => ov.remove();
  document.getElementById('btnConfirmShutdown').onclick = () => { ov.remove(); playShutdownAndExit(); };
}

// Restart confirmation dialog
function openRestartDialog() {
  const existing = document.getElementById('powerOverlay');
  if (existing) existing.remove();

  const ov = document.createElement('div');
  ov.id = 'powerOverlay';
  ov.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.45);backdrop-filter:blur(8px);display:flex;align-items:center;justify-content:center;z-index:100000;';

  const dlg = document.createElement('div');
  dlg.className = 'white-corners';
  dlg.style.cssText = 'width:360px;background:rgba(20,22,25,0.92);padding:20px;border-radius:18px;box-shadow:0 20px 48px rgba(0,0,0,0.7);';
  dlg.innerHTML = `
    <div style="font-weight:800;font-size:18px;margin-bottom:8px;">Restart</div>
    <div style="color:var(--muted);margin-bottom:18px;font-size:14px;">Are you sure you would like to restart the OS?</div>
    <div style="display:flex;gap:10px;justify-content:flex-end;">
      <button id="btnCancelRestart" class="btn">Cancel</button>
      <button id="btnConfirmRestart" class="btn" style="background:rgba(255,255,255,0.14);">Restart</button>
    </div>
  `;

  ov.appendChild(dlg);
  document.body.appendChild(ov);

  document.getElementById('btnCancelRestart').onclick = () => ov.remove();
  document.getElementById('btnConfirmRestart').onclick = () => { ov.remove(); playRestartSequence(); };
}

// Close all apps and clean taskbar in background
function closeAllApps() {
  try {
    // Remove all window DOMs
    document.querySelectorAll('.window').forEach(w => w.remove());
  } catch(_) {}
  try {
    // Remove taskbar icons and clear openWindows registry
    if (state && state.openWindows) {
      Object.keys(state.openWindows).forEach(appId => {
        try { if (typeof removeTaskIcon === 'function') removeTaskIcon(appId); } catch(_) {}
        try { delete state.openWindows[appId]; } catch(_) {}
      });
    }
  } catch(_) {}
  try { hideStartMenuAnimated(); } catch(_) {}
  try { const cm = document.getElementById('contextMenu'); if (cm) cm.style.display = 'none'; } catch(_) {}
}

// Restart overlay + automatic reboot
function playRestartSequence() {
  const audio = document.getElementById('shutdownChime');

  const overlay = document.createElement('div');
  overlay.id = 'restartOverlay';
  overlay.className = 'shutdown-screen';
  overlay.innerHTML = `
    <div class="shutdown-card white-corners-strong">
      <div class="shutdown-title">Power</div>
      <div class="shutdown-sub"><span class="shutdown-spinner"></span>Restarting…</div>
      <div style="color:var(--muted);font-size:13px;">Please wait while RT OS restarts.</div>
    </div>
  `;
  document.body.appendChild(overlay);

  // Close apps in background
  setTimeout(() => { try { closeAllApps(); } catch(_) {} }, 150);

  const doReload = () => { try { location.reload(); } catch(_) { location.href = location.href; } };

  if (!audio) { setTimeout(doReload, 1200); return; }
  try {
    audio.currentTime = 0;
    audio.volume = 0.9;
    const p = audio.play();
    if (p && typeof p.then === 'function') {
      p.then(() => {
        let ended = false;
        const safety = setTimeout(() => { if (!ended) doReload(); }, Math.min(15000, ((audio.duration || 2.5) * 1000) + 300));
        audio.onended = () => { ended = true; clearTimeout(safety); doReload(); };
      }).catch(() => setTimeout(doReload, 1200));
    } else {
      setTimeout(doReload, Math.min(15000, ((audio.duration || 2.5) * 1000) + 300));
    }
  } catch(_) {
    setTimeout(doReload, 1200);
  }
}

// Compact power menu (Windows-like) with Power and Restart
let powerMenuEl = null;
function closePowerMenu(){ if(powerMenuEl){ powerMenuEl.remove(); powerMenuEl=null; document.removeEventListener('click', handlePowerOutside, false);} }
function handlePowerOutside(e){ if(powerMenuEl && !powerMenuEl.contains(e.target) && !e.target.closest('#powerBtn')) closePowerMenu(); }
function openPowerMenu(){
  closePowerMenu();
  const menu = document.createElement('div');
  menu.id = 'powerMenu';
  menu.className = 'white-corners page-enter';
  menu.style.cssText = 'position:fixed;bottom:190px;left:28px;width:240px;background:rgba(24,26,30,0.92);backdrop-filter:blur(12px);-webkit-backdrop-filter:blur(12px);box-shadow:0 28px 80px rgba(0,0,0,0.65);border:1px solid rgba(255,255,255,0.95);border-radius:18px;overflow:hidden;z-index:90040;';
  menu.innerHTML = `
    <div style="display:flex;flex-direction:column;">
      <button id="pmShutdown" class="btn" style="justify-content:flex-start;gap:10px;border:none;border-radius:0;background:transparent;padding:14px 14px;font-weight:800;">
        <span aria-hidden="true">⏻</span> Shut down
      </button>
      <div style="height:1px;background:rgba(255,255,255,0.08);"></div>
      <button id="pmRestart" class="btn" style="justify-content:flex-start;gap:10px;border:none;border-radius:0;background:transparent;padding:14px 14px;font-weight:800;">
        <span aria-hidden="true">↻</span> Restart
      </button>
    </div>`;
  document.body.appendChild(menu);
  powerMenuEl = menu;

  // Try to align under Start menu if visible
  try {
    const sm = document.getElementById('startMenu');
    if (sm && sm.classList.contains('show')) {
      const r = sm.getBoundingClientRect();
      menu.style.left = (r.left + 12) + 'px';
      menu.style.bottom = (window.innerHeight - r.bottom + 12) + 'px';
    }
  } catch(_) {}

  document.getElementById('pmShutdown').onclick = () => { closePowerMenu(); hideStartMenuAnimated(); openPowerDialog(); };
  document.getElementById('pmRestart').onclick = () => { closePowerMenu(); hideStartMenuAnimated(); openRestartDialog(); };
  setTimeout(()=>{ document.addEventListener('click', handlePowerOutside, false); }, 0);
  // Close on Escape
  menu.addEventListener('keydown', (e) => { if (e.key === 'Escape') closePowerMenu(); });
}

// Start menu
const startBtn = document.getElementById("startBtn"), startMenu = document.getElementById("startMenu");
// Start button: prevent selection/copy and add hover class toggles
if (startBtn) {
  startBtn.setAttribute('draggable', 'false');
  startBtn.addEventListener('selectstart', (e) => e.preventDefault());
  startBtn.addEventListener('copy', (e) => e.preventDefault());
  startBtn.addEventListener('dragstart', (e) => e.preventDefault());
  startBtn.addEventListener('mousedown', () => window.getSelection && window.getSelection().removeAllRanges());
  startBtn.addEventListener('mouseenter', () => startBtn.classList.add('hovered'));
  startBtn.addEventListener('mouseleave', () => startBtn.classList.remove('hovered'));
}
let startHideTimer = null;
let startHideInProgress = false;
let startHideCleanup = null;

function hideStartMenuAnimated() {
  if (!startMenu.classList.contains('show')) {
    startMenu.setAttribute('aria-hidden', 'true');
    if (startBtn) startBtn.classList.remove('active', 'pop');
    return;
  }
  if (startMenu.classList.contains('hiding') || startHideInProgress) return;
  startHideInProgress = true;
  if (startBtn) startBtn.classList.remove('active', 'pop');
  startMenu.classList.add('hiding');
  const cleanup = () => {
    startMenu.classList.remove('show', 'hiding');
    startMenu.setAttribute('aria-hidden', 'true');
    startMenu.removeEventListener('animationend', cleanup);
    if (startBtn) startBtn.classList.remove('active', 'pop');
    startHideInProgress = false;
    startHideCleanup = null;
  };
  startHideCleanup = cleanup;
  startMenu.addEventListener('animationend', cleanup, { once: true });
  clearTimeout(startHideTimer);
  startHideTimer = setTimeout(cleanup, 420);
}

function openStartMenuRobust() {
  // Cancel any pending hide animation/timer and show immediately
  if (startMenu.classList.contains('hiding') || startHideInProgress) {
    startMenu.classList.remove('hiding');
    startHideInProgress = false;
    if (startHideTimer) { clearTimeout(startHideTimer); startHideTimer = null; }
    if (startHideCleanup) { startMenu.removeEventListener('animationend', startHideCleanup); startHideCleanup = null; }
  }
  startMenu.classList.add('show');
  startMenu.setAttribute('aria-hidden', 'false');
  try { if (typeof hideSearch === 'function') hideSearch(true); } catch(_) {}
  if (typeof taskbarSearch !== 'undefined' && taskbarSearch) { try { taskbarSearch.blur(); } catch(_) {} }
  try { positionStartMenu(); } catch(_) {}
  if (startBtn) {
    startBtn.classList.remove('pop');
    void startBtn.offsetWidth;
    startBtn.classList.add('active', 'pop');
    setTimeout(() => startBtn.classList.remove('pop'), 220);
  }
}

startBtn.onclick = (e) => {
  e.stopPropagation();
  if (startMenu.classList.contains('show') && !startMenu.classList.contains('hiding')) {
    hideStartMenuAnimated();
  } else {
    openStartMenuRobust();
  }
};

document.addEventListener("click", (ev) => {
  if (!startMenu.contains(ev.target) && ev.target !== startBtn) {
    hideStartMenuAnimated();
  }
});

// Update start menu based on icon style
function updateStartMenu() {
  const startGrid = document.querySelector('.start-grid');
  startGrid.innerHTML = '';
  
  Object.entries(state.installedApps).forEach(([id, app]) => {
    if (app.show) {
      const tile = document.createElement('div');
      tile.className = 'app-tile';
      tile.dataset.app = id;
      
      if (state.settings.iconStyle === 'emoji') {
        tile.textContent = `${app.emoji} ${app.name}`;
      } else {
        tile.textContent = app.name;
      }
      
      tile.onclick = () => { openApp(id); hideStartMenuAnimated(); };
      startGrid.appendChild(tile);
    }
  });
  
  const powerBtn = document.createElement('div');
  powerBtn.className = 'app-tile';
  powerBtn.id = 'powerBtn';
  powerBtn.textContent = '⏻ Power';
  powerBtn.onclick = () => { openPowerMenu(); };
  startGrid.appendChild(powerBtn);
}

// Render desktop icons based on state
function renderDesktopIcons() {
  const desktopIconsEl = document.getElementById("desktopIcons");
  desktopIconsEl.innerHTML = "";
  
  state.desktopIcons.forEach((appId, index) => {
    const app = state.installedApps[appId];
    if (!app) return;
    
    const icon = document.createElement("div");
    icon.className = `icon white-corners ${state.settings.iconStyle === "text" ? "" : "emoji-mode"}`;
    icon.dataset.app = appId;
    icon.dataset.label = app.name;
    icon.style.animationDelay = `${index * 0.1}s`;
    
    const img = document.createElement("div");
    img.className = "img";
    
    if (state.settings.iconStyle === "emoji") {
      img.textContent = app.emoji || app.name;
    } else {
      img.textContent = app.initials || app.name.split(' ').map(w => w[0]).join('').slice(0, 2).toUpperCase();
    }
    
    icon.appendChild(img);
    
    const label = document.createElement("label");
    label.textContent = app.name;
    icon.appendChild(label);
    
    // Click animation then open
    const runClick = () => {
      icon.classList.remove('clicked');
      void icon.offsetWidth; // reflow to restart animation
      icon.classList.add('clicked');
      const openLater = setTimeout(() => openApp(appId), 140);
      icon.addEventListener('animationend', () => {
        icon.classList.remove('clicked');
      }, { once: true });
    };
    icon.addEventListener('click', runClick);
    icon.addEventListener('keydown', (e) => {
      if (e.code === 'Enter' || e.code === 'Space') {
        e.preventDefault();
        runClick();
      }
    });
    icon.oncontextmenu = (e) => {
      e.preventDefault();
      showContextMenu(e, appId);
    };
    
    desktopIconsEl.appendChild(icon);
  });

  // Render file shortcuts (e.g., .nt notes)
  (state.desktopShortcuts || []).forEach((fileId, sIndex) => {
    const f = state.files && state.files[fileId];
    if (!f) return;
    const icon = document.createElement('div');
    icon.className = `icon white-corners ${state.settings.iconStyle === 'text' ? '' : 'emoji-mode'}`;
    icon.dataset.fileId = fileId;
    icon.dataset.label = f.name || 'Note';
    icon.style.animationDelay = `${(state.desktopIcons.length + sIndex) * 0.1}s`;
    const img = document.createElement('div');
    img.className = 'img';
    img.textContent = state.settings.iconStyle === 'emoji' ? '📝' : 'NT';
    const label = document.createElement('label');
    label.textContent = f.name || 'Note.nt';
    icon.append(img, label);
    icon.onclick = () => openNoteWithFile(f, fileId);
    icon.oncontextmenu = (e) => {
      e.preventDefault();
      showContextMenu(e, null);
    };
    desktopIconsEl.appendChild(icon);
  });
}

// Context menu handling
const contextMenu = document.getElementById("contextMenu");
let currentContextApp = null;
let currentShortcutFileId = null; // when right-clicking a desktop file shortcut (e.g., .nt)

function showContextMenu(e, appId = null) {
  currentContextApp = appId;
  currentShortcutFileId = null;
  
  // Show first to measure, then clamp within viewport and above taskbar
  contextMenu.style.display = "block";
  // Initial placement near cursor
  contextMenu.style.left = `${e.clientX}px`;
  contextMenu.style.top = `${e.clientY}px`;
  // Clamp to viewport
  try {
    const r = contextMenu.getBoundingClientRect();
    const vw = window.innerWidth, vh = window.innerHeight;
    const tbEl = document.getElementById('taskbar');
    const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
    const tbH = (!tbEl ? 0 : (centeredAuto ? 0 : tbEl.offsetHeight));
    let left = e.clientX, top = e.clientY;
    // Keep fully on screen
    if (left + r.width > vw - 6) left = Math.max(6, vw - r.width - 6);
    if (top + r.height > vh - tbH - 6) top = Math.max(6, vh - tbH - r.height - 6);
    if (top < 6) top = 6;
    if (left < 6) left = 6;
    contextMenu.style.left = left + 'px';
    contextMenu.style.top = top + 'px';
  } catch(_) {}
  
  const removeShortcutEl = document.getElementById("cmRemoveShortcut");
  if (removeShortcutEl) removeShortcutEl.style.display = 'none';

  if (appId) {
    const app = state.installedApps[appId];
    document.getElementById("cmAddToDesktop").style.display = 
      state.desktopIcons.includes(appId) ? "none" : "block";
    document.getElementById("cmRemoveFromDesktop").style.display = 
      state.desktopIcons.includes(appId) && !app.system ? "block" : "none";
    document.getElementById("cmAppProperties").style.display = "block";
    if (removeShortcutEl) removeShortcutEl.style.display = 'none';
  } else {
    // Check if right-click came from a desktop file shortcut icon
    const iconEl = e.target && e.target.closest ? e.target.closest('#desktopIcons .icon') : null;
    const fileId = iconEl && iconEl.dataset ? iconEl.dataset.fileId : null;
    if (fileId && (state.desktopShortcuts||[]).includes(fileId)) {
      currentShortcutFileId = fileId;
      // Hide app add/remove; show remove shortcut
      document.getElementById("cmAddToDesktop").style.display = "none";
      document.getElementById("cmRemoveFromDesktop").style.display = "none";
      document.getElementById("cmAppProperties").style.display = "none";
      if (removeShortcutEl) removeShortcutEl.style.display = 'block';
    } else {
      document.getElementById("cmAddToDesktop").style.display = "none";
      document.getElementById("cmRemoveFromDesktop").style.display = "none";
      document.getElementById("cmAppProperties").style.display = "none";
      if (removeShortcutEl) removeShortcutEl.style.display = 'none';
    }
  }

  document.getElementById("cmToggleIconStyle").textContent = 
    state.settings.iconStyle === "text" ? "Show Emoji Icons" : "Show Text Icons";
}

document.getElementById("cmRefresh").onclick = () => {
  renderDesktopIcons();
  if (typeof updateStartMenu === 'function') updateStartMenu();
  hideContextMenu();
};

document.getElementById("cmPersonalize").onclick = () => {
  openApp("settings", { section: 'personal' });
  hideContextMenu();
};

document.getElementById("cmAppProperties").onclick = () => {
  if (!currentContextApp) { hideContextMenu(); return; }
  const app = state.installedApps[currentContextApp];
  if (!app) { hideContextMenu(); return; }
  const win = createWindow("", { title: `${app.name} — Properties`, id: makeAppId('props') });
  const body = win.querySelector('.win-body');
  body.style.padding = '16px';
  body.innerHTML = `
    <div style="display:grid;grid-template-columns:140px 1fr;gap:8px;font-size:14px;line-height:1.6;">
      <div style="color:var(--muted)">Name</div><div>${app.name || ''}</div>
      <div style="color:var(--muted)">ID</div><div>${currentContextApp}</div>
      <div style="color:var(--muted)">System App</div><div>${app.system ? 'Yes' : 'No'}</div>
      <div style="color:var(--muted)">Emoji</div><div>${app.emoji || ''}</div>
      <div style="color:var(--muted)">Initials</div><div>${app.initials || ''}</div>
      <div style="color:var(--muted)">Visible in Start</div><div>${app.show ? 'Yes' : 'No'}</div>
    </div>
  `;
  hideContextMenu();
};

function hideContextMenu() {
  contextMenu.style.display = "none";
  currentContextApp = null;
  currentShortcutFileId = null;
}

// Context menu actions
document.getElementById("cmAddToDesktop").onclick = () => {
  if (currentContextApp && !state.desktopIcons.includes(currentContextApp)) {
    state.desktopIcons.push(currentContextApp);
    renderDesktopIcons();
  }
  hideContextMenu();
};

document.getElementById("cmRemoveFromDesktop").onclick = () => {
  if (currentContextApp) {
    state.desktopIcons = state.desktopIcons.filter(id => id !== currentContextApp);
    renderDesktopIcons();
  }
  hideContextMenu();
};

document.getElementById("cmToggleIconStyle").onclick = () => {
  state.settings.iconStyle = state.settings.iconStyle === "text" ? "emoji" : "text";
  renderDesktopIcons();
  updateStartMenu();
  hideContextMenu();
};

// Remove a desktop file shortcut (e.g., .nt note)
const cmRemoveShortcut = document.getElementById('cmRemoveShortcut');
if (cmRemoveShortcut) {
  cmRemoveShortcut.onclick = () => {
    if (currentShortcutFileId) {
      state.desktopShortcuts = (state.desktopShortcuts||[]).filter(id => id !== currentShortcutFileId);
      renderDesktopIcons();
    }
    hideContextMenu();
  };
}

document.addEventListener("click", (e) => {
  if (!contextMenu.contains(e.target)) {
    hideContextMenu();
  }
});

document.addEventListener("keydown", (e) => {
  if (e.key === "Escape") {
    hideContextMenu();
    hideStartMenuAnimated();
  }
});

document.getElementById('desktop').addEventListener('contextmenu', (e) => {
  if (!e.target.closest('.icon') && !e.target.closest('#taskbar')) {
    e.preventDefault();
    showContextMenu(e, null);
  }
});

/* utility to generate consistent app IDs */
function makeAppId(base) {
  const b = (base || "app").toString().toLowerCase().replace(/\s+/g,'-').replace(/[^a-z0-9\-]/g,'');
  return b + '-' + Date.now().toString(36).slice(-5);
}

/* CREATE WINDOW (enhanced with animations): returns appId and window element */
function createWindow(contentNode, opts={}) {
  const appId = opts.id || (opts.title ? opts.title.toLowerCase().replace(/\s+/g,'-') + '-' + Math.random().toString(36).slice(2,6) : makeAppId('app'));
  if (Object.keys(state.openWindows).length >= MAX_WINDOWS && !state.openWindows[appId]) return alert("Max windows open!");
  if (state.openWindows[appId]) {
    const w = state.openWindows[appId];
    if (w.style.display === "none") { 
      w.style.display = "flex"; 
      w.dataset.minimized = ""; 
      focusWindow(w); 
    } else { 
      focusWindow(w); 
    }
    return w;
  }

  const win = document.createElement("div");
  win.className = "window white-corners neon-outline";
  const tbHeight = document.getElementById("taskbar").offsetHeight;
  
  const isMainApp = ["browser", "paint", "settings", "files", "media"].includes(opts.id);
  
  // Helper to compute exact frame up to taskbar top
  function computeMaxFrame() {
    const insetY = 0; // flush to top edge
    const insetX = 0; // flush to side edges
    const tbEl = document.getElementById('taskbar');
    const autohide = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
    const tbTop = tbEl ? tbEl.getBoundingClientRect().top : window.innerHeight;
    const left = insetX;
    const top = insetY;
    const width = Math.max(200, window.innerWidth - insetX*2);
    const height = autohide
      ? Math.max(160, Math.round(window.innerHeight - insetY))
      : Math.max(160, Math.round(tbTop - insetY));
    return { left, top, width, height };
  }

  if (isMainApp) {
    const f = computeMaxFrame();
    win.style.left = f.left + "px";
    win.style.top = f.top + "px";
    win.style.width = f.width + "px";
    win.style.height = f.height + "px";
    win.dataset.maxed = "1";
    win.style.resize = "none";
    win.classList.add('no-elevate');
  } else {
    const tbEl = document.getElementById('taskbar');
    const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
    const tbVisibleH = centeredAuto && !tbEl.classList.contains('hidden') ? tbEl.getBoundingClientRect().height : 0;
    win.style.left = "20px";
    win.style.top = "20px";
    win.style.width = Math.max(480, Math.round(window.innerWidth*0.6)) + "px";
    win.style.height = Math.max(300, Math.round((window.innerHeight - tbVisibleH)*0.6)) + "px";
  }
  
  // Keep windows below system UI layers (taskbar/start/search) and hover zone
  // Taskbar is z-index: 90000, hover zone is 89999 – cap windows to 89998
  state.z = Math.min(++state.z, 89998);
  win.style.zIndex = state.z;
  win.tabIndex = 0;
  win.dataset.appId = appId;

  const titleBar = document.createElement("div"); 
  titleBar.className = "win-title";
  titleBar.innerHTML = `<div style="font-weight:700">${opts.title || "App"}</div>`;
  
  const controls = document.createElement("div"); 
  controls.className = "controls";
  const btnMin = document.createElement("div"); 
  btnMin.className = "wbtn"; 
  btnMin.innerHTML = "─";
  const btnMax = document.createElement("div"); 
  btnMax.className = "wbtn"; 
  btnMax.innerHTML = "⬜";
  const btnClose = document.createElement("div"); 
  btnClose.className = "wbtn"; 
  btnClose.innerHTML = "✕";
  
  controls.append(btnMin, btnMax, btnClose); 
  titleBar.appendChild(controls);

  const body = document.createElement("div"); 
  body.className = "win-body";
  if (typeof contentNode === "string") { 
  body.innerHTML = contentNode; 
  } else if (contentNode instanceof HTMLElement) { 
  body.appendChild(contentNode); 
  } else { 
  body.innerHTML = "<p>Invalid app content</p>"; 
  }
  
  win.append(titleBar, body); 
  desktop.appendChild(win);

  // Add custom resize handles on all sides/corners for smoother resizing
  (function addResizeHandles(){
    const mk = (cls) => { const d = document.createElement('div'); d.className = `win-resize-handle ${cls}`; d.setAttribute('aria-hidden','true'); return d; };
    const handles = [
      mk('edge win-h-n'), mk('edge win-h-s'), mk('edge win-h-e'), mk('edge win-h-w'),
      mk('corner win-h-ne'), mk('corner win-h-nw'), mk('corner win-h-se'), mk('corner win-h-sw')
    ];
    handles.forEach(h => win.appendChild(h));

    let resizing = false, dir = '', startX = 0, startY = 0, startL = 0, startT = 0, startW = 0, startH = 0;
    let raf = 0; let nextFrame = null;
    const minW = 320, minH = 160;

    function bounds() {
      const tbEl = document.getElementById('taskbar');
      const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
      const tb = centeredAuto ? 0 : (tbEl ? tbEl.offsetHeight : 0);
      return { W: window.innerWidth, H: window.innerHeight, tb };
    }

    function onDown(e){
      if (win.dataset.maxed == '1') return;
      e.stopPropagation();
      e.preventDefault();
      resizing = true;
      dir = this.className;
      const r = win.getBoundingClientRect();
      startX = e.clientX; startY = e.clientY;
      startL = r.left; startT = r.top; startW = r.width; startH = r.height;
      win.classList.add('no-elevate');
      document.body.style.userSelect = 'none';
    }

    function applyResize(nx, ny){
      const { W, H, tb } = bounds();
      let left = startL, top = startT, width = startW, height = startH;
      const dx = nx - startX, dy = ny - startY;
      const has = (k)=>dir.indexOf(k) !== -1;
      // Horizontal
      if (has('win-h-e') || has('win-h-ne') || has('win-h-se')) {
        width = Math.max(minW, Math.min(startW + dx, W - startL));
      }
      if (has('win-h-w') || has('win-h-nw') || has('win-h-sw')) {
        const newLeft = Math.max(0, Math.min(startL + dx, startL + startW - minW));
        width = Math.max(minW, startW + (startL - newLeft));
        left = newLeft;
      }
      // Vertical
      if (has('win-h-s') || has('win-h-se') || has('win-h-sw')) {
        height = Math.max(minH, Math.min(startH + dy, H - tb - startT));
      }
      if (has('win-h-n') || has('win-h-ne') || has('win-h-nw')) {
        const maxTop = Math.min(startT + startH - minH, H - tb - minH);
        const newTop = Math.max(0, Math.min(startT + dy, maxTop));
        height = Math.max(minH, startH + (startT - newTop));
        top = newTop;
      }
      // Schedule DOM writes in rAF for smoothness
      nextFrame = { left, top, width, height };
      if (!raf) raf = requestAnimationFrame(() => {
        raf = 0;
        if (!nextFrame) return;
        const f = nextFrame; nextFrame = null;
        win.style.left = Math.round(f.left) + 'px';
        win.style.top = Math.round(f.top) + 'px';
        win.style.width = Math.round(f.width) + 'px';
        win.style.height = Math.round(f.height) + 'px';
      });
    }

    function onMove(e){ if (!resizing) return; applyResize(e.clientX, e.clientY); }
    function onUp(){
      if (!resizing) return;
      resizing = false; dir = '';
      document.body.style.userSelect = '';
      // Remove no-elevate if window not pinned to top
      const topPx = parseInt(win.style.top || '0', 10) || 0;
      if (topPx > 0 && win.dataset.maxed != '1') { win.classList.remove('no-elevate'); }
    }

    handles.forEach(h => h.addEventListener('mousedown', onDown));
    window.addEventListener('mousemove', onMove);
    window.addEventListener('mouseup', onUp);
  })();

  // Allow opening animation even for maximized windows
  win.dataset.opening = "1";
  // Remove the opening flag after the animation finishes
  setTimeout(() => {
    delete win.dataset.opening;
  }, 190);

  state.openWindows[appId] = win;
  addTaskIcon(appId, win, opts.title || appId);
  focusWindow(win);

  let dragging = false, dx = 0, dy = 0;
  titleBar.addEventListener("mousedown", e => {
    if (e.target.classList.contains("wbtn")) return;
    if (win.dataset.maxed) return;
    dragging = true; 
    focusWindow(win);
    const r = win.getBoundingClientRect(); 
    dx = e.clientX - r.left; 
    dy = e.clientY - r.top;
    win.classList.add("mini"); 
    document.body.style.userSelect = "none";
  });
  
  window.addEventListener("mousemove", e => {
    if (!dragging) return;
    let nx = e.clientX - dx, ny = e.clientY - dy;
    const W = window.innerWidth, H = window.innerHeight;
    // In centered autohide overlay mode, allow windows to extend to bottom (taskbar overlays)
    const tbEl = document.getElementById('taskbar');
    const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
    const tb = centeredAuto ? 0 : (tbEl ? tbEl.offsetHeight : 0);
    nx = Math.max(0, Math.min(nx, W - win.offsetWidth));
    ny = Math.max(0, Math.min(ny, H - tb - win.offsetHeight));
    win.style.left = nx + "px"; 
    win.style.top = ny + "px";
  });
  
  window.addEventListener("mouseup", () => {
    dragging = false; 
    win.classList.remove("mini"); 
    document.body.style.userSelect = "";
  });

  btnClose.onclick = (e) => {
    e.stopPropagation();
    if (win.dataset.closing === "1") return; // already closing
    // Play reverse pop animation then remove
    win.dataset.closing = "1";
    // Force reflow to ensure the reverse animation starts reliably
    void win.offsetWidth;
    win.classList.add('closing');
    // Remove task icon and tracking just before removal completes
    removeTaskIcon(appId);
    delete state.openWindows[appId];
    const done = () => { win.removeEventListener('animationend', done); win.remove(); };
    win.addEventListener('animationend', done, { once: true });
    // Safety in case animationend is missed
    setTimeout(done, 500);
  };
  
  btnMin.onclick = () => {
    win.style.display = "none";
    win.dataset.minimized = "1";
  };
  
  btnMax.onclick = () => {
    const tbEl = document.getElementById('taskbar');
    const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
    const tb = centeredAuto ? 0 : (tbEl ? tbEl.offsetHeight : 0);
    if (win.dataset.maxed) {
      const w = Math.max(360, Math.round(window.innerWidth/2)), h = Math.max(240, Math.round((window.innerHeight-tb)/2));
      win.style.width = w + "px"; 
      win.style.height = h + "px";
      win.style.left = (window.innerWidth-w)/2 + "px";
      win.style.top = (window.innerHeight-tb-h)/2 + "px";
      delete win.dataset.maxed; 
      win.style.resize = "none"; // keep custom handles
      win.classList.remove('no-elevate');
    } else {
      win.dataset.left = win.style.left; 
      win.dataset.top = win.style.top; 
      win.dataset.width = win.style.width; 
      win.dataset.height = win.style.height;
      const f = computeMaxFrame();
      win.style.left = f.left + "px"; 
      win.style.top = f.top + "px"; 
      win.style.width = f.width + "px"; 
      win.style.height = f.height + "px";
      win.dataset.maxed = "1"; 
      win.style.resize = "none";
      win.classList.add('no-elevate');
    }
  };

  win.addEventListener('mousedown', () => focusWindow(win));

  // Ensure manual resizes never push window under the taskbar
  try {
    const ro = new ResizeObserver(() => {
      if (win.dataset.maxed == "1") return;
      const tbEl = document.getElementById('taskbar');
      const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
      const tb = centeredAuto ? 0 : (tbEl ? tbEl.offsetHeight : 0);
      const H = window.innerHeight;
      const topPx = parseInt(win.style.top || '0', 10) || 0;
      const maxH = Math.max(160, H - tb - topPx);
      const curH = win.offsetHeight;
      if (curH > maxH) {
        win.style.height = maxH + 'px';
      }
      // Keep within horizontal bounds too
      const W = window.innerWidth;
      const leftPx = parseInt(win.style.left || '0', 10) || 0;
      const maxW = Math.max(320, W - leftPx);
      const curW = win.offsetWidth;
      if (curW > maxW) {
        win.style.width = maxW + 'px';
      }
    });
    ro.observe(win);
  } catch (_) {}

  return win;
}

function focusWindow(win) {
  if (!win) return;
  // Cap z-index so it never surpasses UI layers (taskbar/start/search)
  state.z = Math.min(++state.z, 89998);
  win.style.zIndex = state.z;
  document.querySelectorAll(".window").forEach(w => w.classList.remove("focus"));
  win.classList.add("focus");
  if (win.style.display !== "none") win.dataset.minimized = "";
  // If maximized or pinned to the very top, avoid upward elevation transform (prevents top-corner clipping)
  const topPx = parseInt(win.style.top || '0', 10) || 0;
  if (win.dataset.maxed == "1" || topPx <= 0) {
    win.classList.add('no-elevate');
  } else {
    win.classList.remove('no-elevate');
  }
}

function addTaskIcon(appId, win, title) {
  if (taskMid.querySelector(`[data-app-id="${appId}"]`)) return;
  const icon = document.createElement("button");
  icon.className = "taskbar-app btn";
  icon.textContent = title || appId;
  icon.type = "button";
  icon.dataset.appId = appId;
  icon.onclick = () => {
    const w = state.openWindows[appId];
    if (!w) { icon.remove(); return; }
    if (w.style.display === "none" || w.dataset.minimized === "1") {
      w.style.display = "flex";
      w.dataset.minimized = "";
      focusWindow(w);
    } else {
      w.style.display = "none";
      w.dataset.minimized = "1";
    }
  };
  taskMid.appendChild(icon);
}

function removeTaskIcon(appId) {
  const el = taskMid.querySelector(`[data-app-id="${appId}"]`);
  if (el) el.remove();
}

window.addEventListener("resize", () => {
  document.querySelectorAll(".window").forEach(win => {
    if (win.dataset.maxed == "1") {
      const f = (typeof computeMaxFrame === 'function') ? computeMaxFrame() : {left:0, top:0, width: window.innerWidth, height: window.innerHeight - document.getElementById('taskbar').offsetHeight};
      win.style.left = f.left + "px";
      win.style.top = f.top + "px";
      win.style.width = f.width + "px"; 
      win.style.height = f.height + "px";
    } else {
      // Keep normal windows within viewport and above taskbar
      const tbEl = document.getElementById('taskbar');
      const centeredAuto = !!(tbEl && tbEl.classList.contains('centered') && tbEl.classList.contains('autohide'));
      const tb = centeredAuto ? 0 : (tbEl ? tbEl.offsetHeight : 0);
      const W = window.innerWidth, H = window.innerHeight;
      const leftPx = parseInt(win.style.left || '0', 10) || 0;
      const topPx = parseInt(win.style.top || '0', 10) || 0;
      const maxLeft = Math.max(0, W - win.offsetWidth);
      const maxTop = Math.max(0, H - tb - win.offsetHeight);
      if (leftPx > maxLeft) win.style.left = maxLeft + 'px';
      if (topPx > maxTop) win.style.top = maxTop + 'px';
    }
  });
  try { positionStartMenu(); } catch(_) {}
  try { if (wifiPanelEl) { const tmp = wifiPanelEl; wifiPanelEl = null; tmp.remove(); renderWifiPanel(); } } catch(_) {}
});

// Position Start menu near Start button, clamped within viewport
function positionStartMenu() {
  const tb = document.getElementById('taskbar');
  if (!tb || !startBtn || !startMenu) return;
  if (!startMenu.classList.contains('show')) return;
  const br = startBtn.getBoundingClientRect();
  const mr = startMenu.getBoundingClientRect();
  // Place above taskbar with small gap
  const tbRect = tb.getBoundingClientRect();
  const bottom = Math.max(12, window.innerHeight - tbRect.top + 12);
  startMenu.style.bottom = bottom + 'px';
  // Align left edge to start button, but clamp to viewport
  const left = Math.min(Math.max(12, br.left), window.innerWidth - mr.width - 12);
  startMenu.style.left = left + 'px';
}

/* OPEN APP routing */
function openApp(app, opts) {
  if (app === "browser") createWindow(browserApp({url:"https://example.com"}), {title:"Browser", id:"browser"});
  if (app === "settings") createWindow(settingsApp(opts), {title:"Settings", id:"settings"});
  if (app === "files") createWindow(filesApp(), {title:"Files", id:"files"});
  if (app === "notes") createWindow(notesApp(opts), {title:"Notepad", id:"notepad"});
  if (app === "trash") createWindow(trashApp(), {title:"Trash", id:"trash"});
  if (app === "calc") createWindow(calcApp(), {title:"Calculator", id:makeAppId('calc')});
  if (app === "clock") createWindow(clockApp(), {title:"Clock", id:makeAppId('clock')});
  if (app === "cmd") createWindow(cmdApp(), {title:"CMD", id:"cmd"});
  if (app === "paint") createWindow(paintApp(), {title:"Paint", id:"paint"});
  if (app === "media") createWindow(mediaApp(), {title:"Media Player", id:"media"});
}

// Helper: open or reuse Media Player with a given file object from Files app
function openMediaWithFile(file) {
  try {
    // If media window exists, bring it to front and send event
    const existing = state.openWindows["media"];
    if (existing) {
      existing.style.display = "flex";
      existing.dataset.minimized = "";
      focusWindow(existing);
      const ev = new CustomEvent('rt-open-media', { detail: { file } });
      document.dispatchEvent(ev);
      return;
    }
    // Otherwise create a new media window seeded with the file
    const w = createWindow(mediaApp({file}), { title: 'Media Player', id: 'media' });
    bringToFront(w);
  } catch (e) {
    console.warn('Failed to open media:', e);
  }
}

// Helper: open or reuse Notepad with a given .nt file object from Files app
function openNoteWithFile(file, fileId) {
  try {
    const wins = document.querySelectorAll('.window');
    for (const w of wins) {
      const title = w.querySelector('.win-title span');
      if (title && /Notepad/i.test(title.textContent||'')) {
        bringToFront(w);
        w.dispatchEvent(new CustomEvent('rtos-open-note', { detail: { file, fileId } }));
        return;
      }
    }
  } catch(_) {}
  // Otherwise open new
  createWindow(notesApp({ file, fileId }), { title: 'Notepad', id: 'notepad' });
}

document.querySelectorAll(".icon, .app-tile").forEach(el => {
  if (el.dataset.app) el.onclick = () => openApp(el.dataset.app);
});

/* SEARCH / quick open */
const SEARCH_APPS = [
  {text:"Browser",app:"browser",desc:"Browse the web"},
  {text:"Files",app:"files",desc:"View files & wallpapers"},
  {text:"Settings",app:"settings",desc:"Customize your experience"},
  {text:"Notepad",app:"notes",desc:"Write down your notes"},
  {text:"Trash",app:"trash",desc:"Deleted files"},
  {text:"Calculator",app:"calc",desc:"Calculator widget"},
  {text:"Clock",app:"clock",desc:"Clock widget"},
  {text:"CMD",app:"cmd",desc:"Command prompt"},
  {text:"Paint",app:"paint",desc:"Drawing application"},
  {text:"Media Player",app:"media",desc:"Play videos and music"}
];

const taskbarSearch = document.getElementById("taskbarSearch"), searchResults = document.getElementById("searchResults");
let __searchInteracting = false; // guard while clicking inside results

function hideSearch(clear=false){
  if (searchResults) searchResults.style.display = "none";
  if (taskbarSearch) {
    if (clear) taskbarSearch.value = "";
    // In centered mode, always collapse back to icon-only when not interacting
    try {
      const tb = document.getElementById('taskbar');
      const centered = tb && tb.classList.contains('centered');
      if (centered) {
        taskbarSearch.classList.remove('expanded');
        taskbarSearch.placeholder = 'Search';
        taskbarSearch.blur();
      } else {
        // Full-width keeps long placeholder
        taskbarSearch.placeholder = 'Search RT OS, apps or web...';
      }
    } catch(_) {}
  }
}

if (taskbarSearch) {
  taskbarSearch.addEventListener('focus', () => {
    if (startMenu && startMenu.classList.contains('show')) hideStartMenuAnimated();
  });
  // mark interactions inside results to prevent blur-clear while clicking a result
  if (searchResults) {
    const arm = () => { __searchInteracting = true; setTimeout(()=>{ __searchInteracting = false; }, 260); };
    searchResults.addEventListener('mousedown', arm, {capture:true});
    searchResults.addEventListener('pointerdown', arm, {capture:true});
    searchResults.addEventListener('touchstart', arm, {capture:true, passive:true});
  }
  taskbarSearch.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      hideSearch(true);
      taskbarSearch.blur();
    } else if (e.key === 'Enter') {
      const first = searchResults && searchResults.querySelector('.search-result');
      if (first) {
        first.click();
        e.preventDefault();
      }
    }
  });
}

// Build a sticky header with a back arrow inside the search popup
function buildSearchHeader(titleText = 'Search'){
  const header = document.createElement('div');
  header.className = 'search-header';
  const back = document.createElement('div');
  back.className = 'back';
  back.innerHTML = '&#8592;'; // left arrow
  back.onclick = (e) => { e.stopPropagation(); e.preventDefault(); switchSearchToStart(); };
  const title = document.createElement('div');
  title.className = 'title';
  title.textContent = titleText;
  header.appendChild(back);
  header.appendChild(title);
  return header;
}

function renderSearchChrome(hintText = 'Type to search apps...'){
  if (!searchResults) return;
  searchResults.innerHTML = '';
  searchResults.appendChild(buildSearchHeader('Search'));
  const hint = document.createElement('div');
  hint.className = 'search-hint';
  hint.textContent = hintText;
  searchResults.appendChild(hint);
}

let uiSwitchGuardUntil = 0;

function switchStartToSearch(){
  // Slide hint on Start menu and instantly switch to the search side
  if (startMenu){
    uiSwitchGuardUntil = Date.now() + 260;
    startMenu.classList.add('to-search');
    // Short hint, then instantly hide Start and show search
    setTimeout(() => {
      startMenu.classList.remove('to-search','show','hiding');
      startMenu.setAttribute('aria-hidden','true');
      if (startBtn) startBtn.classList.remove('active','pop');
      // Show search chrome and focus the real search input
      if (searchResults){
        renderSearchChrome();
        searchResults.style.display = 'block';
        positionSearchResults();
      }
      if (taskbarSearch){ taskbarSearch.blur(); taskbarSearch.focus(); }
    }, 160);
  }
}

function switchSearchToStart(){
  // Hide search instantly and show Start
  uiSwitchGuardUntil = Date.now() + 260;
  hideSearch(true);
  if (startMenu){
    startMenu.classList.remove('hiding');
    startMenu.classList.add('show');
    startMenu.setAttribute('aria-hidden','false');
    if (startBtn){
      startBtn.classList.remove('pop');
      void startBtn.offsetWidth;
      startBtn.classList.add('active','pop');
      setTimeout(()=>startBtn.classList.remove('pop'),220);
    }
  }
}

function positionSearchResults() {
  if (!taskbarSearch || !searchResults) return;
  const r = taskbarSearch.getBoundingClientRect();
  // Ensure we know panel width for centering
  const prevDisplay = searchResults.style.display;
  const prevVis = searchResults.style.visibility;
  if (getComputedStyle(searchResults).display === 'none') {
    searchResults.style.visibility = 'hidden';
    searchResults.style.display = 'block';
  }
  const panelW = searchResults.offsetWidth || 320;
  // Restore visibility state if we temporarily changed it
  if (prevDisplay === '' || prevDisplay === 'none') {
    searchResults.style.display = prevDisplay || 'none';
    searchResults.style.visibility = prevVis || '';
  }
  // Compute centered left: center under the search box
  let left = Math.round(r.left + (r.width - panelW) / 2);
  // Snap to 2px grid for crisp alignment with Start menu panel
  left = left - (left % 2);
  searchResults.style.left = left + 'px';
  // Use Start menu's configured bottom if available to match vertical baseline
  let smBottom = 100;
  const sm = document.getElementById('startMenu');
  if (sm) {
    const cs = getComputedStyle(sm);
    const bv = parseInt(cs.bottom, 10);
    if (!isNaN(bv)) smBottom = bv;
  }
  searchResults.style.bottom = smBottom + 'px';
}

taskbarSearch.oninput = () => {
  const q = taskbarSearch.value.trim().toLowerCase();
  searchResults.innerHTML = "";
  // Always include back header
  searchResults.appendChild(buildSearchHeader('Search'));
  if (!q) {
    const hint = document.createElement('div');
    hint.className = 'search-hint';
    hint.textContent = 'Type to search apps...';
    searchResults.appendChild(hint);
    // Show chrome even with no query
    searchResults.style.display = "block";
    positionSearchResults();
    return;
  }
  // Ensure Start menu is closed while searching
  if (startMenu && startMenu.classList.contains('show')) hideStartMenuAnimated();
  
  let found = SEARCH_APPS.filter(x => 
    x.text.toLowerCase().includes(q) || 
    x.desc.toLowerCase().includes(q)
  );

  if (found.length === 0) {
    const none = document.createElement('div');
    none.className = 'search-result';
    none.textContent = 'No apps found';
    searchResults.appendChild(none);
  }

  found.slice(0,5).forEach(app => {
    let r = document.createElement("div");
    r.className = "search-result";
    r.innerHTML = `<strong>${app.text}</strong><div style="font-size:13px; color:#aaa;">${app.desc}</div>`;
    r.onclick = () => {
      hideSearch(true);
      openApp(app.app);
    };
    r.oncontextmenu = (e) => {
      e.preventDefault();
      showContextMenu(e, app.app);
    };
    searchResults.appendChild(r);
  });
  // Show, then position to allow exact width for centering
  searchResults.style.display = "block";
  positionSearchResults();
};

document.body.addEventListener("click", e => {
  // During UI switch animations, ignore stray body clicks
  if (Date.now() < uiSwitchGuardUntil) return;
  if (e.target !== taskbarSearch && !searchResults.contains(e.target)) {
    hideSearch(false);
  }
});

// Reposition on resize in case of layout changes
window.addEventListener('resize', () => {
  if (searchResults && searchResults.style.display === 'block') positionSearchResults();
});

// Inject a fake Start menu search row (no typing) and wire instant switching
setTimeout(()=>{
  const sm = document.getElementById('startMenu');
  if (sm && !sm.querySelector('.start-search')){
    const fake = document.createElement('div');
    fake.className = 'start-search';
    fake.innerHTML = `<div class="mag"></div><div class="label">Search apps</div><div class="arrow">&#8594;</div>`; // right arrow
    fake.onclick = (e) => { e.stopPropagation(); switchStartToSearch(); };
    sm.insertBefore(fake, sm.firstChild);
  }
}, 0);

/* ----------------------
   Browser app (IMPROVED)
   ---------------------- */
function browserApp(opts={}) {
  const root = document.createElement("div"); 
  root.style.display = "flex"; 
  root.style.flexDirection = "column"; 
  root.style.height = "100%";
  
  const urlBar = document.createElement("div");
  urlBar.className = "browser-url-bar";
  // Navigation toolbar (Back, Forward, Restart)
  const navBar = document.createElement('div');
  navBar.style.display = 'flex';
  navBar.style.alignItems = 'center';
  navBar.style.gap = '6px';
  
  function makeIconButton(title, svg) {
    const b = document.createElement('button');
    b.className = 'btn';
    b.title = title;
    b.style.display = 'inline-flex';
    b.style.alignItems = 'center';
    b.style.justifyContent = 'center';
    b.style.width = '32px';
    b.style.height = '32px';
    b.style.padding = '0';
    b.style.borderRadius = '10px';
    b.innerHTML = svg;
    return b;
  }
  const btnBack = makeIconButton('Back', `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M15 19l-7-7 7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`);
  const btnForward = makeIconButton('Forward', `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 5l7 7-7 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`);
  // Clean circular restart icon: tuned gap & arrow alignment
  const btnRestart = makeIconButton('Restart', `
    <svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <g transform="rotate(-10 12 12)">
        <circle cx="12" cy="12" r="9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-dasharray="47.5 8.5" stroke-dashoffset="6.5"/>
        <path d="M20.7 7.9 L22.5 7.9 L21.3 9.7 Z" fill="currentColor"/>
      </g>
    </svg>`);
  navBar.append(btnBack, btnForward, btnRestart);
  
  const urlInput = document.createElement("input");
  urlInput.className = "browser-url-input";
  urlInput.value = opts.url || "https://example.com";
  urlInput.placeholder = "Enter website URL";
  
  const goButton = document.createElement("button");
  goButton.className = "browser-go-button";
  goButton.innerText = "Go";
  
  urlBar.append(navBar, urlInput, goButton);
  
  const loadingBar = document.createElement("div");
  loadingBar.className = "browser-loading-bar";
  loadingBar.style.display = "none";
  loadingBar.style.height = "3px";
  loadingBar.style.background = "white";
  loadingBar.style.width = "0%";
  
  const iframeContainer = document.createElement("div");
  iframeContainer.className = "browser-iframe-container";
  iframeContainer.style.flex = "1";
  iframeContainer.style.position = "relative";
  
  const iframe = document.createElement("iframe");
  iframe.className = "browser-iframe";
  iframe.style.width = "100%";
  iframe.style.height = "100%";
  iframe.style.border = "none";
  iframeContainer.appendChild(iframe);
  
  const notice = document.createElement('div');
  notice.style.cssText = 'position:absolute;inset:0;z-index:100;display:none;align-items:center;justify-content:center;pointer-events:none;';

  let jitterAttached = false;
  // Loading state/timers to avoid idle animations
  let isLoading = false;
  let tickTimeoutId = null;
  let wobbleTimeoutId = null;
  function attachJitterListeners(){ jitterAttached = true; /* disabled jitter to avoid shutter */ }
  attachJitterListeners();
  
  function noticeSpinner(on){
    return on ? `<svg width=\"64\" height=\"64\" viewBox=\"0 0 50 50\" style=\"display:block\">\n      <circle cx=\"25\" cy=\"25\" r=\"18\" stroke=\"#fff\" stroke-width=\"6\" fill=\"none\" stroke-linecap=\"round\" stroke-dasharray=\"90 60\">\n        <animateTransform attributeName=\"transform\" type=\"rotate\" from=\"0 25 25\" to=\"360 25 25\" dur=\"0.9s\" repeatCount=\"indefinite\"/>\n      </circle>\n    </svg>` : '';
  }

  // mount container with notice and iframe
  iframeContainer.append(notice, iframe);
  root.append(urlBar, loadingBar, iframeContainer);
  
  // Load URL function
  let loadSeq = 0; // increments per navigation to prevent tick races
  function loadUrl(url) {
    if (!url) return;
    const isConnected = !!(state.wifi && state.wifi.connected);
    if (!isConnected) {
      // Block navigation when offline/connecting; show centered overlay
      loadingBar.style.display = 'none';
      iframe.src = 'about:blank';
      updateNotice();
      return;
    }
    
    // Add https:// if missing
    if (!url.startsWith('http://') && !url.startsWith('https://') && !url.startsWith('about:')) {
      url = 'https://' + url;
      urlInput.value = url;
    }
    // History management
    currentUrl = url;
    if (!navigatingViaHistory) {
      // Truncate forward stack then push
      if (historyIndex < history.length - 1) history.splice(historyIndex + 1);
      history.push(url);
      historyIndex = history.length - 1;
    }
    
    const netId = state.wifi && state.wifi.network;
    const terrible = netId === 'terrible-hotstop';
    const mySeq = ++loadSeq;
    
    // Show loading bar with progression
    loadingBar.style.display = "block";
    const targetCap = terrible ? 92 : 99; // terrible stops earlier before onload
    let progress = terrible ? 6 : 25;
    loadingBar.style.width = progress + "%";

    function startLoad() {
      if (mySeq !== loadSeq) return; // canceled by a newer navigation
      // Always attempt to load, but on terrible hotspot we might not fully complete UI-wise
      const partialMode = terrible && Math.random() < 0.35; // sometimes never fully completes visually
      // Set iframe source
      iframe.src = url;
      
      // Finish when iframe loads
      iframe.onload = () => {
        if (mySeq !== loadSeq) return;
        isLoading = false;
        if (partialMode) {
          // Keep bar around 90% and visible, no wobble to avoid shutter
          let stuck = 90;
          loadingBar.style.width = stuck + '%';
          loadingBar.style.display = 'block';
          iframe.style.opacity = '0.98';
        } else {
          loadingBar.style.width = "100%";
          setTimeout(() => { loadingBar.style.display = "none"; }, terrible ? 450 : 140);
          iframe.style.opacity = '1';
        }
        navigatingViaHistory = false;
        updateNavButtons();
      };
      iframe.onerror = () => {
        if (mySeq !== loadSeq) return;
        isLoading = false;
        // On error, keep bar visible briefly then hide (no alerts/popups)
        loadingBar.style.width = terrible ? '88%' : '100%';
        setTimeout(() => { if (mySeq === loadSeq) loadingBar.style.display = 'none'; }, terrible ? 1400 : 400);
      };
    }

    function tick() {
      if (mySeq !== loadSeq) return; // canceled
      if (!isLoading) return; // do not animate when idle
      if (progress < targetCap) {
        const step = terrible ? (0.3 + Math.random()*1.0) : 6.5; // larger jitter/smaller increments on terrible
        progress = Math.min(targetCap, progress + step);
        loadingBar.style.width = progress + '%';
        const delay = terrible ? (380 + Math.random()*680) : 70; // jitter only on terrible
        tickTimeoutId = setTimeout(tick, delay);
      }
    }

    // Fallback if onload never fires (blocked embeds):
    const fallbackMs = terrible ? 10000 : 2500;
    const thisSeq = mySeq;
    setTimeout(() => {
      if (thisSeq !== loadSeq) return;
      if (terrible) {
        // On terrible, keep it visually stuck near 90% (do not force-complete)
        loadingBar.style.display = 'block';
        loadingBar.style.width = '89%';
      } else {
        loadingBar.style.width = '100%';
        setTimeout(() => { if (thisSeq === loadSeq) loadingBar.style.display = 'none'; }, 200);
      }
      isLoading = false;
    }, fallbackMs);

    isLoading = true;
    tickTimeoutId = setTimeout(tick, terrible ? 650 : 20);
    setTimeout(startLoad, terrible ? 3200 + Math.random()*3200 : 60);
  }
  
  function updateNotice(){
    const isConnected = !!(state.wifi && state.wifi.connected);
    const isConnecting = !!(state.wifi && state.wifi.connecting);
    if (isConnected) { notice.style.display = 'none'; return; }
    const ssid = state.wifi && (state.wifi.target ? state.wifiNetworks[state.wifi.target].ssid : '');
    const icon = isConnecting
      ? `<div style=\"display:inline-flex;transform:scale(1.35);margin-bottom:6px\">${wifiBarsIcon(3,'#fff','rgba(255,255,255,0.35)')}</div>`
      : `<div style=\"display:inline-flex;transform:scale(1.35);margin-bottom:6px\">${wifiBarsIcon(0,'rgba(255,255,255,0.55)','rgba(255,255,255,0.25)','xcut')}</div>`;
    const box = document.createElement('div');
    box.style.cssText = 'background:rgba(24,26,30,0.9);backdrop-filter:blur(14px);-webkit-backdrop-filter:blur(14px);color:#fff;padding:30px 34px;border-radius:22px;border:1px solid rgba(255,255,255,0.95);box-shadow:0 28px 80px rgba(0,0,0,0.65);min-width:420px;max-width:82%;font-weight:800;display:flex;flex-direction:column;align-items:center;gap:12px;';
    box.innerHTML = `${icon}${isConnecting ? '<div>' + noticeSpinner(true) + '</div>' : ''}<div style=\"font-size:18px;opacity:.98\">${isConnecting ? ('Connecting' + (ssid? ' to '+ssid : '') + '…') : 'No internet connection'}</div><div style=\"font-size:13px;opacity:.78\">Open Settings → Network & Wi‑Fi to connect.</div>`;
    notice.innerHTML = '';
    notice.appendChild(box);
    notice.style.display = 'flex';
  }

  // Event listeners
  // In-app navigation state
  const history = [];
  let historyIndex = -1;
  let navigatingViaHistory = false;
  let currentUrl = '';

  function updateNavButtons(){
    btnBack.disabled = historyIndex <= 0;
    btnForward.disabled = historyIndex < 0 || historyIndex >= history.length - 1;
  }

  goButton.onclick = () => { navigatingViaHistory = false; loadUrl(urlInput.value); updateNavButtons(); };
  btnBack.onclick = () => {
    if (historyIndex > 0) {
      historyIndex -= 1;
      navigatingViaHistory = true;
      const u = history[historyIndex];
      urlInput.value = u;
      loadUrl(u);
      updateNavButtons();
    }
  };
  btnForward.onclick = () => {
    if (historyIndex < history.length - 1) {
      historyIndex += 1;
      navigatingViaHistory = true;
      const u = history[historyIndex];
      urlInput.value = u;
      loadUrl(u);
      updateNavButtons();
    }
  };
  btnRestart.onclick = () => {
    // Reload current URL and rely on the loading bar animation (no popup)
    const u = currentUrl || urlInput.value;
    navigatingViaHistory = true; // do not push a new history entry
    loadUrl(u);
    updateNavButtons();
  };
  
  urlInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      navigatingViaHistory = false;
      loadUrl(urlInput.value);
      updateNavButtons();
    }
  });
  
  // Load initial URL
  setTimeout(() => loadUrl(urlInput.value), 100);

  // React to Wi‑Fi state changes
  let autoLoadedAfterConnect = false;
  const wifiHandler = () => {
    const isConnected = !!(state.wifi && state.wifi.connected);
    if (!isConnected) {
      loadingBar.style.display = 'none';
      iframe.src = 'about:blank';
      autoLoadedAfterConnect = false;
      isLoading = false;
      if (tickTimeoutId) { clearTimeout(tickTimeoutId); tickTimeoutId = null; }
      if (wobbleTimeoutId) { clearTimeout(wobbleTimeoutId); wobbleTimeoutId = null; }
    }
    updateNotice();
    updateNavButtons();
    // Auto-load once after regaining connection
    if (isConnected && !autoLoadedAfterConnect) {
      autoLoadedAfterConnect = true;
      if (iframe.src === 'about:blank' || !iframe.src) {
        navigatingViaHistory = false;
        loadUrl(urlInput.value);
      }
    }
  };
  document.addEventListener('wifi-changed', wifiHandler);
  // Ensure initial state
  wifiHandler();
  
  return root;
}

/* ----------------------
   Media Player app (NEW)
   ---------------------- */
function mediaApp(opts = {}) {
  const root = document.createElement("div");
  root.className = "media-player";
  
  root.innerHTML = "<h2>RT Media Player</h2><p>Play videos and audio files</p>";
  
  const controls = document.createElement("div");
  controls.className = "media-controls";
  
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = "video/*,audio/*";
  fileInput.style.flex = "1";
  
  controls.appendChild(fileInput);
  
  const videoElement = document.createElement("video");
  videoElement.controls = true;
  videoElement.style.display = "none";
  
  const audioElement = document.createElement("audio");
  audioElement.controls = true;
  audioElement.style.display = "none";
  
  const noMediaMessage = document.createElement("div");
  noMediaMessage.innerHTML = "<p style='text-align:center;margin-top:40px;color:var(--muted)'>Select a video or audio file to play</p>";
  noMediaMessage.style.flex = "1";
  noMediaMessage.style.display = "flex";
  noMediaMessage.style.alignItems = "center";
  noMediaMessage.style.justifyContent = "center";
  
  root.append(controls, videoElement, audioElement, noMediaMessage);

  function loadFromFileObject(fileObj) {
    if (!fileObj) return;
    const isVideo = fileObj.type && fileObj.type.startsWith('video/');
    const isAudio = fileObj.type && fileObj.type.startsWith('audio/');
    const src = fileObj.dataURL || '';
    if (isVideo) {
      videoElement.style.display = "block";
      audioElement.style.display = "none";
      videoElement.src = src;
      noMediaMessage.style.display = "none";
      videoElement.play().catch(() => {});
    } else if (isAudio) {
      audioElement.style.display = "block";
      videoElement.style.display = "none";
      audioElement.src = src;
      noMediaMessage.style.display = "none";
      audioElement.play().catch(() => {});
    }
  }

  fileInput.onchange = function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const fileURL = URL.createObjectURL(file);
    const isVideo = file.type.startsWith('video/');
    if (isVideo) {
      videoElement.style.display = "block";
      audioElement.style.display = "none";
      videoElement.src = fileURL;
      noMediaMessage.style.display = "none";
      videoElement.play().catch(() => {});
    } else if (file.type.startsWith('audio/')) {
      audioElement.style.display = "block";
      videoElement.style.display = "none";
      audioElement.src = fileURL;
      noMediaMessage.style.display = "none";
      audioElement.play().catch(() => {});
    } else {
      alert("Please select a valid video or audio file.");
    }
  };

  // If opened with a file from Files app, load it
  if (opts && opts.file) {
    loadFromFileObject(opts.file);
  }

  // Listen for future open requests if window is reused
  const onOpenMedia = (e) => {
    if (e && e.detail && e.detail.file) {
      loadFromFileObject(e.detail.file);
    }
  };
  document.addEventListener('rt-open-media', onOpenMedia);
  // Clean up when the window is closed: observer to remove listener when DOM node removed
  const observer = new MutationObserver(() => {
    if (!root.isConnected) {
      document.removeEventListener('rt-open-media', onOpenMedia);
      observer.disconnect();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
  
  return root;
}

/* ----------------------
   Settings app (wallpaper + upload)
   ---------------------- */
function settingsApp(opts) {
  const root = document.createElement('div');
  root.className = 'settings-container';

  // Left nav
  const nav = document.createElement('div');
  nav.className = 'settings-nav';
  const navTitle = document.createElement('div');
  navTitle.className = 'settings-nav-title';
  navTitle.textContent = 'Settings';
  const navInfo = document.createElement('div');
  navInfo.className = 'settings-nav-item';
  navInfo.textContent = 'System info';
  const navPersonal = document.createElement('div');
  navPersonal.className = 'settings-nav-item';
  navPersonal.textContent = 'Personalization';
  const navNetwork = document.createElement('div');
  navNetwork.className = 'settings-nav-item';
  navNetwork.textContent = 'Network & Wi‑Fi';
  const navAccounts = document.createElement('div');
  navAccounts.className = 'settings-nav-item';
  navAccounts.textContent = 'RT Accounts';
  nav.append(navTitle, navInfo, navPersonal, navNetwork, navAccounts);

  // Right content
  const content = document.createElement('div');
  content.className = 'settings-content';

  const header = document.createElement('div');
  header.className = 'settings-section';

  const page = document.createElement('div');
  page.className = 'settings-section settings-page';

  // -------- RT Accounts Page (inside settingsApp scope) --------
  function renderAccountsPage() {
    page.innerHTML = '';
    header.innerHTML = '';
    // Header
    const hero = document.createElement('div'); hero.className = 'settings-hero';
    const logo = document.createElement('div'); logo.className = 'settings-hero-logo'; logo.textContent = '👤';
    const heroText = document.createElement('div'); heroText.className = 'settings-hero-text';
    const heroTitle = document.createElement('div'); heroTitle.className = 'settings-hero-title'; heroTitle.textContent = 'RT Accounts';
    const heroSub = document.createElement('div'); heroSub.className = 'settings-h2'; heroSub.textContent = 'Create or sign in to save your settings and files across restarts.';
    // Match other sections: lighter, not bold
    heroSub.style.fontWeight = '400';
    heroSub.style.color = 'var(--muted)';
    heroText.append(heroTitle, heroSub);
    hero.append(logo, heroText);
    header.append(hero);

    const current = getCurrentUser();
    const status = document.createElement('div'); status.className = 'settings-section'; status.style.padding = '14px';
    const statusRow = document.createElement('div'); statusRow.style.display = 'flex'; statusRow.style.alignItems = 'center'; statusRow.style.gap = '12px';
    const avatar = current && current.avatarDataURL 
      ? `<img src="${current.avatarDataURL}" alt="avatar" style="width:40px;height:40px;border-radius:10px;object-fit:cover;border:1px solid rgba(255,255,255,0.08);"/>`
      : `<div style="width:40px;height:40px;border-radius:10px;display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.04);">👤</div>`;
    const info = document.createElement('div');
    info.innerHTML = `<div style="font-weight:800;">${current ? current.name : 'Guest'}</div><div style="color:var(--muted);font-size:13px;">${current ? 'Signed in' : 'Not signed in'}</div>`;
    const avatarWrap = document.createElement('div'); avatarWrap.innerHTML = avatar;
    statusRow.append(avatarWrap, info);
    const spacer = document.createElement('div'); spacer.style.flex = '1'; statusRow.append(spacer);
    if (current) {
      const btnOutInline = document.createElement('button'); btnOutInline.className = 'btn'; btnOutInline.textContent = 'Sign out';
      btnOutInline.onclick = () => { signOutAccount(); renderAccountsPage(); };
      statusRow.append(btnOutInline);
    }
    status.append(statusRow);

    // Create / Sign-in card
    const create = document.createElement('div'); create.className = 'settings-section'; create.style.padding = '14px';
    const createTitle = document.createElement('div'); createTitle.className = 'settings-h1'; createTitle.textContent = 'Create or sign in';
    const form = document.createElement('div'); form.style.display = 'grid'; form.style.gridTemplateColumns = '180px 1fr'; form.style.gap = '10px 14px'; form.style.alignItems = 'center';
    const lblName = document.createElement('div'); lblName.className = 'kv k'; lblName.textContent = 'Display name';
    const nameInp = document.createElement('input'); nameInp.placeholder = 'e.g., Alex';
    const lblPass = document.createElement('div'); lblPass.className = 'kv k'; lblPass.textContent = 'Password';
    const passWrap = document.createElement('div');
    const passInp = document.createElement('input'); passInp.placeholder = 'Use a throwaway password'; passInp.type = 'password'; passInp.style.display = 'block'; passInp.style.width = '100%';
    const passHint = document.createElement('div'); passHint.style.fontSize = '12px'; passHint.style.color = 'var(--muted)'; passHint.style.marginTop = '4px'; passHint.textContent = 'Do not use your real account password. This is a sandbox simulator.';
    passWrap.append(passInp, passHint);
    const lblAvatar = document.createElement('div'); lblAvatar.className = 'kv k'; lblAvatar.textContent = 'Avatar';
    const avInp = document.createElement('input'); avInp.type = 'file'; avInp.accept = 'image/*';
    const lblActions = document.createElement('div'); lblActions.className = 'kv k'; lblActions.textContent = '';
    const actions = document.createElement('div'); actions.style.display = 'flex'; actions.style.gap = '8px';
    const btnCreate = document.createElement('button'); btnCreate.className = 'btn'; btnCreate.textContent = 'Continue';
    actions.append(btnCreate);
    form.append(lblName, nameInp, lblPass, passWrap, lblAvatar, avInp, lblActions, actions);
    create.append(createTitle, form);

    // Remove separate password warning card; inline hint under the password field is sufficient

    // Input styling to match OS
    const styleInput = (el) => {
      el.style.background = 'rgba(255,255,255,0.04)';
      el.style.border = '1px solid rgba(255,255,255,0.08)';
      el.style.color = '#fff';
      el.style.padding = '10px 12px';
      el.style.borderRadius = '10px';
      el.style.outline = 'none';
      el.addEventListener('focus', () => {
        el.style.border = '1px solid var(--accent)';
        el.style.boxShadow = '0 0 0 3px rgba(0, 150, 255, 0.18)';
      });
      el.addEventListener('blur', () => {
        el.style.border = '1px solid rgba(255,255,255,0.08)';
        el.style.boxShadow = 'none';
      });
    };
    styleInput(nameInp);
    styleInput(passInp);

    let avatarDataURL = '';
    avInp.addEventListener('change', () => {
      const f = avInp.files && avInp.files[0];
      if (!f) { avatarDataURL = ''; return; }
      const r = new FileReader(); r.onload = () => { avatarDataURL = r.result; }; r.readAsDataURL(f);
    });
    btnCreate.onclick = () => {
      const name = (nameInp.value||'').trim();
      const pw = String(passInp.value||'');
      if (!name) { alert('Please enter a display name.'); return; }
      if (!pw) { alert('Please enter a password.'); return; }
      const existing = findAccountByName(name);
      if (existing) {
        const res = signInAccount(existing.id, pw);
        if (!res.ok) { alert(res.msg||'Incorrect password'); return; }
        renderAccountsPage(); return;
      }
      createAccount(name, avatarDataURL, pw);
      renderAccountsPage();
    };

    // Accounts list
    const list = document.createElement('div'); list.className = 'settings-section'; list.style.padding = '14px';
    const title = document.createElement('div'); title.className = 'settings-h1'; title.textContent = 'Existing accounts'; list.append(title);
    loadAccounts();
    const users = Object.values(__accounts.users);
    if (users.length === 0) {
      const empty = document.createElement('div'); empty.style.color = 'var(--muted)'; empty.textContent = 'No accounts yet.'; list.append(empty);
    } else {
      const currentUser = getCurrentUser();
      users.forEach(u => {
        const row = document.createElement('div'); row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '10px'; row.style.padding = '8px 0';
        row.innerHTML = `${u.avatarDataURL ? `<img src="${u.avatarDataURL}" alt="avatar" style=\"width:32px;height:32px;border-radius:8px;object-fit:cover;border:1px solid rgba(255,255,255,0.08);\"/>` : `<div style=\"width:32px;height:32px;border-radius:8px;display:flex;align-items:center;justify-content:center;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.04);\">👤</div>`}<div style="font-weight:700;">${u.name}</div>`;
        const spacer = document.createElement('div'); spacer.style.flex = '1';
        const btnSignIn = document.createElement('button'); btnSignIn.className = 'btn'; btnSignIn.textContent = (currentUser && currentUser.id === u.id) ? 'Signed in' : 'Sign in'; btnSignIn.disabled = !!(currentUser && currentUser.id === u.id);
        btnSignIn.onclick = () => {
          const pw = prompt('Enter password for '+u.name+':');
          const res = signInAccount(u.id, pw||'');
          if (!res.ok) alert(res.msg||'Failed to sign in');
          renderAccountsPage();
        };
        const btnDel = document.createElement('button'); btnDel.className = 'btn'; btnDel.textContent = 'Delete';
        btnDel.onclick = () => {
          if (confirm('Delete account '+u.name+'? This removes saved data for this account.')) {
            deleteAccount(u.id);
            renderAccountsPage();
          }
        };
        row.append(spacer, btnSignIn, btnDel);
        list.append(row);
      });
    }

    // Sign out
    // Always allow creating another account even when signed in
    page.append(status, create, list);
  }

  // Track current active tab to avoid unintended switches during Wi‑Fi changes
  let currentTab = 'info';
  // Keep a reference to network wifi-changed handler to remove cleanly
  let wifiChangeHandlerRef = null;

  function renderInfoPage() {
    page.innerHTML = '';
    // Hero header
    header.innerHTML = '';
    const hero = document.createElement('div'); hero.className = 'settings-hero';
    const logo = document.createElement('div'); logo.className = 'settings-hero-logo'; logo.textContent = 'RT';
    const heroText = document.createElement('div'); heroText.className = 'settings-hero-text';
    const heroTitle = document.createElement('div'); heroTitle.className = 'settings-hero-title'; heroTitle.textContent = 'RT OS';
    const heroSub = document.createElement('div'); heroSub.className = 'settings-hero-sub'; heroSub.textContent = 'Stable Edition';
    const versionBadge = document.createElement('div'); versionBadge.className = 'settings-version-badge';
    const meta = { version: 'v1.0', build: new Date().toLocaleString(), edition: 'Stable' };
    versionBadge.textContent = `${meta.version} • Build ${meta.build}`;
    heroText.append(heroTitle, heroSub, versionBadge);
    hero.append(logo, heroText);
    header.append(hero);

    // Info grid
    const title = document.createElement('div'); title.className = 'settings-h1'; title.textContent = 'System info';
    const kv = document.createElement('div'); kv.className = 'kv';
    const add = (k, v) => {
      const kEl = document.createElement('div'); kEl.className = 'k'; kEl.textContent = k;
      const vEl = document.createElement('div'); vEl.className = 'v'; vEl.textContent = v;
      kv.append(kEl, vEl);
    };
    add('OS', 'RT OS');
    add('Edition', meta.edition);
    add('Version', meta.version);
    add('Build date', meta.build);
    page.append(title, kv);
  }

  function renderPersonalizationPage() {
    page.innerHTML = '';
    header.innerHTML = '';
    const hero = document.createElement('div'); hero.className = 'settings-hero';
    const logo = document.createElement('div'); logo.className = 'settings-hero-logo'; logo.textContent = '🎨';
    const heroText = document.createElement('div'); heroText.className = 'settings-hero-text';
    const heroTitle = document.createElement('div'); heroTitle.className = 'settings-hero-title'; heroTitle.textContent = 'Personalization';
    const heroSub = document.createElement('div'); heroSub.className = 'settings-hero-sub'; heroSub.textContent = 'Wallpaper and accent color';
    heroText.append(heroTitle, heroSub);
    hero.append(logo, heroText);
    header.append(hero);

    // Wallpaper grid (scrollable) + Stock default card + Upload card
    const wScroll = document.createElement('div');
    wScroll.style.maxHeight = 'none';
    wScroll.style.overflowY = 'visible';
    wScroll.style.paddingRight = '0px';
    wScroll.style.marginBottom = '12px';
    const wList = document.createElement('div');
    wList.style.display = 'flex';
    wList.style.flexWrap = 'wrap';
    wList.style.gap = '12px';
    // Stock default card
    const cStock = document.createElement('div'); cStock.className = 'white-corners'; cStock.style.width = '160px'; cStock.style.padding = '10px'; cStock.style.cursor = 'pointer';
    const swStock = document.createElement('div'); swStock.style.height = '100px'; swStock.style.borderRadius = '10px'; swStock.style.background = state.wallpapers['gradient-1']; swStock.style.border = '1px solid rgba(255,255,255,0.03)'; swStock.style.backgroundSize = 'cover';
    const nameStock = document.createElement('div'); nameStock.style.marginTop = '8px'; nameStock.style.fontSize = '13px'; nameStock.innerText = 'Stock (Default)';
    cStock.append(swStock, nameStock);
    cStock.onclick = () => {
      state.settings.wallpaper = 'gradient-1';
      applyWallpaper();
      state.settings.accent = 'system';
      state.settings.accentColor = '#ffffff';
      applyAccent();
    };
    wList.append(cStock);
    // Upload card (hidden input + tile)
    const uploadHidden = document.createElement('input'); uploadHidden.type = 'file'; uploadHidden.accept = 'image/*'; uploadHidden.style.display = 'none';
    const cUpload = document.createElement('div'); cUpload.className = 'white-corners'; cUpload.style.width = '160px'; cUpload.style.padding = '10px'; cUpload.style.cursor = 'pointer';
    const swUpload = document.createElement('div'); swUpload.style.height = '100px'; swUpload.style.borderRadius = '10px'; swUpload.style.border = '1px dashed rgba(255,255,255,0.08)'; swUpload.style.display = 'flex'; swUpload.style.alignItems = 'center'; swUpload.style.justifyContent = 'center'; swUpload.style.color = 'var(--muted)'; swUpload.textContent = '+ Add Wallpaper';
    const nameUpload = document.createElement('div'); nameUpload.style.marginTop = '8px'; nameUpload.style.fontSize = '13px'; nameUpload.innerText = 'Upload image…';
    cUpload.append(swUpload, nameUpload);
    cUpload.onclick = () => uploadHidden.click();
    uploadHidden.onchange = e => {
      const f = e.target.files[0];
      if (!f) return;
      const id = 'custom-' + Date.now();
      const reader = new FileReader();
      reader.onload = () => {
        state.wallpapers[id] = `url("${reader.result}")`;
        state.settings.wallpaper = id;
        applyWallpaper();
        const c = document.createElement('div'); c.className = 'white-corners'; c.style.width = '160px'; c.style.padding = '10px'; c.style.cursor = 'pointer';
        const sw = document.createElement('div'); sw.style.height = '100px'; sw.style.borderRadius = '10px'; sw.style.background = state.wallpapers[id]; sw.style.border = '1px solid rgba(255,255,255,0.03)'; sw.style.backgroundSize = 'cover';
        const name = document.createElement('div'); name.style.marginTop = '8px'; name.style.fontSize = '13px'; name.innerText = id;
        c.append(sw, name);
        c.onclick = () => { state.settings.wallpaper = id; applyWallpaper(); };
        wList.prepend(c); // show newest first
      };
      reader.readAsDataURL(f);
    };
    wList.append(cUpload);
    // Other wallpapers
    Object.keys(state.wallpapers).filter(k => k !== 'gradient-1').forEach(k => {
      const c = document.createElement('div'); c.className = 'white-corners'; c.style.width = '160px'; c.style.padding = '10px'; c.style.cursor = 'pointer';
      const sw = document.createElement('div'); sw.style.height = '100px'; sw.style.borderRadius = '10px'; sw.style.background = state.wallpapers[k]; sw.style.border = '1px solid rgba(255,255,255,0.03)'; sw.style.backgroundSize = 'cover';
      const name = document.createElement('div'); name.style.marginTop = '8px'; name.style.fontSize = '13px'; name.innerText = k;
      c.append(sw, name);
      c.onclick = () => { state.settings.wallpaper = k; applyWallpaper(); };
      wList.append(c);
    });
    wScroll.append(wList);

    // append hidden input so it exists in DOM
    wScroll.appendChild(uploadHidden);

    // Icon style toggle
    const iconStyleToggle = document.createElement('button');
    iconStyleToggle.className = 'btn';
    iconStyleToggle.textContent = state.settings.iconStyle === 'text' ? 'Switch to Emoji Icons' : 'Switch to Text Icons';
    iconStyleToggle.style.marginTop = '12px';
    iconStyleToggle.onclick = () => {
      state.settings.iconStyle = state.settings.iconStyle === 'text' ? 'emoji' : 'text';
      iconStyleToggle.textContent = state.settings.iconStyle === 'text' ? 'Switch to Emoji Icons' : 'Switch to Text Icons';
      renderDesktopIcons();
      updateStartMenu();
    };

    // Accent picker (includes Stock white)
    const accentWrap = document.createElement('div');
    accentWrap.style.marginTop = '16px';
    const accentTitle = document.createElement('div'); accentTitle.className = 'settings-h1'; accentTitle.textContent = 'Accent color';
    const accents = [
      {key:'stock', color:'#ffffff'},
      {key:'blue', color:'#5aa7ff'},
      {key:'red', color:'#ff5a5f'},
      {key:'green', color:'#39d98a'},
      {key:'pink', color:'#ff6bc8'},
      {key:'purple', color:'#9b7bff'},
      {key:'orange', color:'#ff9f45'},
      {key:'teal', color:'#2ec9c9'}
    ];
    const accentList = document.createElement('div');
    accentList.style.display = 'flex';
    accentList.style.flexWrap = 'wrap';
    accentList.style.gap = '10px';
    accents.forEach(a => {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.style.display = 'flex';
      btn.style.alignItems = 'center';
      btn.style.gap = '8px';
      btn.style.border = '1px solid rgba(255,255,255,0.08)';
      const dot = document.createElement('span');
      dot.style.width = '16px'; dot.style.height = '16px'; dot.style.borderRadius = '50%'; dot.style.display = 'inline-block'; dot.style.background = a.color; dot.style.boxShadow = '0 0 10px rgba(0,0,0,0.25)';
      const label = document.createElement('span'); label.textContent = (a.key === 'stock') ? 'White (Stock)' : a.key;
      btn.append(dot, label);
      const syncActive = () => {
        const isActive = (a.key === 'stock') ? (state.settings.accent === 'system') : (state.settings.accent === a.key);
        btn.style.outline = isActive ? '2px solid var(--accent)' : 'none';
      };
      syncActive();
      btn.onclick = () => {
        if (a.key === 'stock') {
          state.settings.accent = 'system';
          state.settings.accentColor = '#ffffff';
        } else {
          state.settings.accent = a.key;
          state.settings.accentColor = a.color;
        }
        applyAccent();
        // refresh states
        Array.from(accentList.children).forEach(ch => ch.style.outline = 'none');
        syncActive();
      };
      accentList.append(btn);
    });
    accentWrap.append(accentTitle, accentList);

    // Taskbar style picker
    const taskbarWrap = document.createElement('div');
    taskbarWrap.style.marginTop = '16px';
    const tbTitle = document.createElement('div'); tbTitle.className = 'settings-h1'; tbTitle.textContent = 'Taskbar style';
    const tbRow = document.createElement('div'); tbRow.style.display = 'flex'; tbRow.style.gap = '10px'; tbRow.style.flexWrap = 'wrap';
    const makeTbBtn = (key, label) => {
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = label;
      const sync = () => { btn.style.outline = (state.settings.taskbarStyle === key) ? '2px solid var(--accent)' : 'none'; };
      sync();
      btn.onclick = () => { state.settings.taskbarStyle = key; sync(); Array.from(tbRow.children).forEach(ch => { if (ch !== btn) ch.style.outline = 'none'; }); applyTaskbarStyle(); };
      return btn;
    };
    tbRow.append(
      makeTbBtn('full', 'Full width (default)'),
      makeTbBtn('centered', 'Centered dock')
    );
    taskbarWrap.append(tbTitle, tbRow);

    page.append(wScroll, iconStyleToggle, accentWrap, taskbarWrap);
  }

  // Sound settings page removed

  function renderNetworkPage() {
    page.innerHTML = '';
    header.innerHTML = '';
    // Emoji hero header for Network (consistent with other sections)
    const hero = document.createElement('div'); hero.className = 'settings-hero';
    const logo = document.createElement('div'); logo.className = 'settings-hero-logo'; logo.innerHTML = wifiBarsIcon(4);
    const heroText = document.createElement('div'); heroText.className = 'settings-hero-text';
    const heroTitle = document.createElement('div'); heroTitle.className = 'settings-hero-title'; heroTitle.textContent = 'Network & Wi‑Fi';
    const heroSub = document.createElement('div'); heroSub.className = 'settings-hero-sub'; heroSub.textContent = 'Connections and status';
    heroText.append(heroTitle, heroSub);
    hero.append(logo, heroText);
    header.append(hero);

    const status = document.createElement('div');
    status.className = 'settings-section';
    const connected = !!(state.wifi && state.wifi.connected);
    const connecting = !!(state.wifi && state.wifi.connecting);
    const current = connected && state.wifi.network ? state.wifiNetworks[state.wifi.network] : null;
    status.innerHTML = `<div style="font-weight:600">Status: ${connecting ? `Connecting${state.wifi.target? ' to '+state.wifiNetworks[state.wifi.target].ssid : ''}…` : (connected ? 'Connected' : 'Disconnected')}${connected ? ` to ${current.ssid}` : ''}</div>`;

    // Toggle
    const toggleRow = document.createElement('div');
    toggleRow.style.display = 'flex';
    toggleRow.style.alignItems = 'center';
    toggleRow.style.justifyContent = 'space-between';
    toggleRow.style.margin = '12px 0 4px';
    const tLabel = document.createElement('div');
    tLabel.textContent = 'Wi‑Fi';
    const tBtn = document.createElement('button');
    tBtn.className = 'btn';
    const setToggleUi = () => { tBtn.textContent = connecting ? 'Connecting…' : ((state.wifi && state.wifi.connected) ? 'Turn Off' : 'Turn On'); tBtn.disabled = !!connecting; };
    setToggleUi();
    tBtn.onclick = () => {
      if (state.wifi && state.wifi.connected) {
        disconnectWifi();
      } else {
        // default to RT Hotspot when turning on without selection
        connectWifi('rt-hotspot');
      }
      setToggleUi();
      renderNetworkPage();
    };
    toggleRow.append(tLabel, tBtn);

    const listTitle = document.createElement('div');
    listTitle.className = 'settings-h2';
    listTitle.textContent = 'Available networks';

    const list = document.createElement('div');
    list.className = 'settings-section';

    const makeRow = (id, profile) => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.justifyContent = 'space-between';
      row.style.padding = '10px 0';
      const left = document.createElement('div');
      left.innerHTML = `<div style="font-weight:600">${profile.ssid}</div><div style="opacity:.75;font-size:12px;display:flex;align-items:center;gap:8px"><span style="display:inline-flex;transform:scale(0.85);transform-origin:left center;">${wifiBarsIcon((profile.strength||0))}</span><span>Latency ~${profile.latency}ms</span></div>`;
      const right = document.createElement('div');
      const btn = document.createElement('button');
      btn.className = 'btn';
      const isThis = !!(state.wifi.connected && state.wifi.network === id);
      const isTarget = !!(state.wifi.connecting && state.wifi.target === id);
      const isConnecting = !!state.wifi.connecting;
      // Preserve original texts: "Disconnect", "Connecting…", "Connect"
      // Behavior: clicking "Connecting…" cancels; clicking "Connect" while connecting switches.
      btn.textContent = isThis ? 'Disconnect' : (isTarget ? 'Connecting…' : 'Connect');
      // Do not blanket-disable during connecting; allow user to cancel or switch
      btn.disabled = false;
      btn.onclick = () => {
        if (isThis) {
          // Disconnect current network
          disconnectWifi();
        } else if (isTarget) {
          // Cancel in-progress connection
          disconnectWifi();
        } else {
          // Switch or connect to selected network
          connectWifi(id);
        }
        renderNetworkPage();
      };
      right.appendChild(btn);
      row.append(left, right);
      return row;
    };

    list.append(
      makeRow('rt-hotspot', state.wifiNetworks['rt-hotspot']),
      makeRow('terrible-hotstop', state.wifiNetworks['terrible-hotstop'])
    );

    page.append(status, toggleRow, listTitle, list);

    // Live updates during connecting: only when Network tab is active
    if (wifiChangeHandlerRef) {
      document.removeEventListener('wifi-changed', wifiChangeHandlerRef);
      wifiChangeHandlerRef = null;
    }
    wifiChangeHandlerRef = () => {
      try {
        if (currentTab === 'network') {
          renderNetworkPage();
        }
      } catch(_) {}
    };
    document.addEventListener('wifi-changed', wifiChangeHandlerRef, { once: true });
  }

  function setActive(tab) {
    currentTab = tab;
    if (tab === 'info') {
      navInfo.classList.add('active');
      navPersonal.classList.remove('active');
      navNetwork.classList.remove('active');
      navAccounts.classList.remove('active');
      renderInfoPage();
    } else if (tab === 'personal') {
      navPersonal.classList.add('active');
      navInfo.classList.remove('active');
      navNetwork.classList.remove('active');
      navAccounts.classList.remove('active');
      renderPersonalizationPage();
    } else if (tab === 'network') {
      navNetwork.classList.add('active');
      navInfo.classList.remove('active');
      navPersonal.classList.remove('active');
      navAccounts.classList.remove('active');
      renderNetworkPage();
    } else {
      navAccounts.classList.add('active');
      navInfo.classList.remove('active');
      navPersonal.classList.remove('active');
      navNetwork.classList.remove('active');
      renderAccountsPage();
    }
    // trigger enter animation
    page.classList.remove('page-enter'); void page.offsetWidth; page.classList.add('page-enter');
  }

  navInfo.onclick = () => setActive('info');
  navPersonal.onclick = () => setActive('personal');
  navNetwork.onclick = () => setActive('network');
  navAccounts.onclick = () => setActive('accounts');

  // Initial
  let initialTab = 'info';
  if (opts && opts.section === 'personal') initialTab = 'personal';
  if (opts && opts.section === 'network') initialTab = 'network';
  setActive(initialTab);
  
  content.append(header, page);
  root.append(nav, content);
  return root;
}

/* ----------------------
   FILE MANAGER (IMPROVED)
   ---------------------- */
function filesApp() {
  const root = document.createElement("div"); 
  root.className = "files-app-container";
  
  const sidebar = document.createElement("div");
  sidebar.className = "files-sidebar";
  sidebar.innerHTML = "<h3>Folders</h3>";
  
  const foldersList = document.createElement("div");
  foldersList.style.marginTop = "12px";
  
  // Add folders
  state.folders.forEach(folder => {
    const folderEl = document.createElement("div");
    folderEl.className = "folder-item";
    folderEl.innerHTML = `<span>📁</span> ${folder}`;
    folderEl.onclick = () => {
      document.querySelectorAll('.folder-item').forEach(el => el.classList.remove('active'));
      folderEl.classList.add('active');
      renderFiles(folder);
    };
    foldersList.appendChild(folderEl);
  });
  
  // Add root folder
  const rootFolder = document.createElement("div");
  rootFolder.className = "folder-item active";
  rootFolder.innerHTML = `<span>📁</span> All Files`;
  rootFolder.onclick = () => {
    document.querySelectorAll('.folder-item').forEach(el => el.classList.remove('active'));
    rootFolder.classList.add('active');
    renderFiles('root');
  };
  foldersList.appendChild(rootFolder);
  
  sidebar.appendChild(foldersList);
  
  const content = document.createElement("div");
  content.className = "files-content";
  
  const toolbar = document.createElement("div");
  toolbar.className = "files-toolbar";
  
  const btnNewFolder = document.createElement("button"); 
  btnNewFolder.className = "btn"; 
  btnNewFolder.innerText = "New Folder";
  btnNewFolder.onclick = () => {
    const name = prompt("Folder name:");
    if (name) {
      state.folders.push(name);
      const folderEl = document.createElement("div");
      folderEl.className = "folder-item";
      folderEl.innerHTML = `<span>📁</span> ${name}`;
      folderEl.onclick = () => {
        document.querySelectorAll('.folder-item').forEach(el => el.classList.remove('active'));
        folderEl.classList.add('active');
        renderFiles(name);
      };
      foldersList.insertBefore(folderEl, rootFolder);
    }
  };
  
  const inputUpload = document.createElement("input"); 
  inputUpload.type = "file"; 
  inputUpload.multiple = true;
  inputUpload.style.flex = "1";
  
  const search = document.createElement("input"); 
  search.placeholder = "Search files..."; 
  search.style.flex = "1";
  
  toolbar.append(btnNewFolder, inputUpload, search);
  
  const fileView = document.createElement("div");
  fileView.className = "files-view";
  fileView.id = "filesView";
  
  content.append(toolbar, fileView);
  root.append(sidebar, content);

  function renderFiles(folder) {
    fileView.innerHTML = "";
    const q = (search.value || "").toLowerCase();
    const files = Object.entries(state.files || {}).filter(([id, f]) => {
      const inFolder = !folder || folder === 'root' || (f.folder || 'root') === folder;
      const matchQuery = !q || (f.name || "").toLowerCase().includes(q);
      return inFolder && matchQuery;
    });
    
    if (files.length === 0) { 
      fileView.innerHTML = "<div style='color:var(--muted);text-align:center;padding:40px'>No files</div>"; 
      return; 
    }
    
    const grid = document.createElement("div");
    grid.className = "file-manager-grid";
    
    files.forEach(([id, f]) => {
      const item = document.createElement("div");
      item.className = "file-item";
      
      const icon = document.createElement("div");
      icon.className = "file-icon";
      
      // Set appropriate icon based on file type
      if (f.type) {
        if (f.type.startsWith("image/")) {
          icon.innerHTML = "🖼️";
        } else if (f.type.startsWith("video/")) {
          icon.innerHTML = "🎬";
        } else if (f.type.startsWith("audio/")) {
          icon.innerHTML = "🎵";
        } else if (f.type.includes("text") || f.type.includes("pdf")) {
          icon.innerHTML = "📄";
        } else {
          icon.innerHTML = "📁";
        }
      } else {
        icon.innerHTML = "📁";
      }
      
      const name = document.createElement("div");
      name.className = "file-name";
      name.textContent = f.name;
      
      item.append(icon, name);
      
      item.onclick = () => {
        openFilePreview(f);
      };
      
      item.oncontextmenu = (e) => {
        e.preventDefault();
        showFileContextMenu(e, id, f);
      };
      
      grid.appendChild(item);
    });
    
    fileView.appendChild(grid);
  }

  function openFilePreview(file) {
    // Route .nt to Notepad
    if ((file.name||'').toLowerCase().endsWith('.nt') || (file.type||'').includes('rtos-note')) {
      // Find the id by matching object reference
      const entry = Object.entries(state.files || {}).find(([id, f]) => f === file);
      openNoteWithFile(file, entry ? entry[0] : undefined);
      return;
    }
    // Route audio/video to Media Player
    if (file.type && (file.type.startsWith('video/') || file.type.startsWith('audio/'))) {
      openMediaWithFile(file);
      return;
    }
    const previewWin = createWindow("", {title: `Preview: ${file.name}`, id: makeAppId('preview')});
    const body = previewWin.querySelector('.win-body');
    body.innerHTML = "";
    body.style.textAlign = "center";
    
    if (file.type && file.type.startsWith('image/')) {
      const img = document.createElement('img');
      img.src = file.dataURL;
      img.className = "file-preview";
      body.appendChild(img);
    } else if (file.type && (file.type.startsWith('text/') || file.type.includes('pdf'))) {
      if (file.text) {
        const pre = document.createElement('pre');
        pre.className = "text-preview";
        pre.textContent = file.text;
        body.appendChild(pre);
      } else {
        body.innerHTML = '<div class="binary-preview">This file cannot be previewed as text</div>';
      }
    } else {
      body.innerHTML = '<div class="binary-preview">This file type cannot be previewed</div>';
    }
  }

  function showFileContextMenu(e, fileId, file) {
    const menu = document.getElementById('fileContextMenu');
    menu.style.display = 'block';
    menu.style.left = `${e.clientX}px`;
    menu.style.top = `${e.clientY}px`;
    const isNt = (file.name||'').toLowerCase().endsWith('.nt') || (file.type||'').includes('rtos-note');
    const addToDesk = document.getElementById('fileCtxAddToDesktop');
    if (addToDesk) {
      addToDesk.style.display = isNt ? 'block' : 'none';
      addToDesk.onclick = () => {
        if (!isNt) return;
        state.desktopShortcuts = state.desktopShortcuts || [];
        if (!state.desktopShortcuts.includes(fileId)) {
          state.desktopShortcuts.push(fileId);
          renderDesktopIcons();
        }
        menu.style.display = 'none';
      };
    }
    
    document.getElementById('fileCtxOpen').onclick = () => {
      if ((file.name||'').toLowerCase().endsWith('.nt') || (file.type||'').includes('rtos-note')) {
        const entry = Object.entries(state.files || {}).find(([id, f]) => f === file);
        openNoteWithFile(file, entry ? entry[0] : undefined);
      } else if (file.type && (file.type.startsWith('video/') || file.type.startsWith('audio/'))) {
        openMediaWithFile(file);
      } else {
        openFilePreview(file);
      }
      menu.style.display = 'none';
    };
    
    document.getElementById('fileCtxRename').onclick = () => {
      const newName = prompt("Enter new name:", file.name);
      if (newName && newName.trim() !== '') {
        state.files[fileId].name = newName;
        renderFiles('root');
      }
      menu.style.display = 'none';
    };
    
    document.getElementById('fileCtxDelete').onclick = () => {
      if (confirm(`Move "${file.name}" to trash?`)) {
        state.trash[fileId] = { ...file, deletedAt: Date.now() };
        delete state.files[fileId];
        renderFiles('root');
      }
      menu.style.display = 'none';
    };
    
    document.getElementById('fileCtxProperties').onclick = () => {
      alert(`File Properties:\nName: ${file.name}\nType: ${file.type || 'Unknown'}\nSize: ${file.dataURL.length / 1000} KB`);
      menu.style.display = 'none';
    };
  }

  document.addEventListener('click', (ev) => {
    const m = document.getElementById('fileContextMenu');
    if (m && !m.contains(ev.target)) m.style.display = 'none';
  });

  inputUpload.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    for (const f of files) {
      const id = 'f' + Date.now().toString(36) + Math.random().toString(36).slice(2,4);
      const reader = new FileReader();
      await new Promise((res, rej) => {
        reader.onload = () => { 
          // Try to read as text for text files, including custom .nt
          const isNt = (f.name||'').toLowerCase().endsWith('.nt');
          if (isNt || f.type.startsWith('text/')) {
            const textReader = new FileReader();
            textReader.onload = () => {
              state.files[id] = { 
                name: f.name, 
                type: isNt ? 'text/rtos-note' : f.type, 
                dataURL: reader.result,
                text: textReader.result,
                folder: 'root' 
              }; 
              res();
            };
            textReader.readAsText(f);
          } else {
            state.files[id] = { 
              name: f.name, 
              type: f.type, 
              dataURL: reader.result, 
              folder: 'root' 
            }; 
            res();
          }
        };
        reader.onerror = rej;
        reader.readAsDataURL(f);
      });
    }
    renderFiles('root');
  };

  search.oninput = () => renderFiles('root');

  renderFiles('root');

  return root;
}

/* ----------------------
   Trash Bin app
   ---------------------- */
function trashApp() {
  const root = document.createElement("div"); 
  root.style.display = "flex"; 
  root.style.flexDirection = "column"; 
  root.style.height = "100%";
  
  root.innerHTML = `
    <h2>Trash</h2>
    <p>Deleted files and applications.</p>
    <div style="display:flex; gap:8px; margin-bottom:12px;">
      <button class="btn" id="trashEmpty">Empty Trash</button>
      <button class="btn" id="trashRestoreAll">Restore All</button>
    </div>
    <div id="trashList" style="flex:1; overflow:auto;"></div>
  `;
  
  const trashList = root.querySelector("#trashList");
  const emptyBtn = root.querySelector("#trashEmpty");
  const restoreAllBtn = root.querySelector("#trashRestoreAll");
  
  function renderTrash() {
    trashList.innerHTML = "";
    const items = Object.entries(state.trash || {});
    
    if (items.length === 0) {
      trashList.innerHTML = '<div class="trash-empty">Trash is empty</div>';
      return;
    }
    
    items.forEach(([id, item]) => {
      const el = document.createElement("div");
      el.className = "trash-item";
      
      const date = new Date(item.deletedAt || Date.now());
      const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
      
      el.innerHTML = `
        <div class="trash-item-name">
          <div style="font-weight:700">${item.name}</div>
          <div style="font-size:12px;color:var(--muted)">${dateStr}</div>
        </div>
      `;
      
      const restoreBtn = document.createElement("div");
      restoreBtn.className = "trash-restore";
      restoreBtn.innerText = "Restore";
      restoreBtn.onclick = () => {
        state.files[id] = item;
        delete state.trash[id];
        renderTrash();
      };
      
      el.appendChild(restoreBtn);
      trashList.appendChild(el);
    });
  }
  
  emptyBtn.onclick = () => {
    if (confirm("Permanently delete all items in Trash?")) {
      state.trash = {};
      renderTrash();
    }
  };
  
  restoreAllBtn.onclick = () => {
    Object.entries(state.trash || {}).forEach(([id, item]) => {
      state.files[id] = item;
      delete state.trash[id];
    });
    renderTrash();
  };
  
  renderTrash();
  return root;
}

/* ----------------------
   Notes app
   ---------------------- */
function notesApp(opts = {}) {
  const root = document.createElement('div');
  root.style.display = 'flex';
  root.style.flexDirection = 'column';
  root.style.height = '100%';

  // Header / toolbar
  const header = document.createElement('div');
  header.style.display = 'flex';
  header.style.gap = '8px';
  header.style.alignItems = 'center';
  header.style.padding = '8px 8px 0 8px';

  const titleEl = document.createElement('div');
  titleEl.style.flex = '1';
  titleEl.style.fontWeight = '700';
  titleEl.style.color = 'var(--muted)';
  titleEl.textContent = 'Notepad';

  const btnNew = document.createElement('button'); btnNew.className = 'btn'; btnNew.textContent = 'New';
  const btnSave = document.createElement('button'); btnSave.className = 'btn'; btnSave.textContent = 'Save to File Manager';
  const btnExport = document.createElement('button'); btnExport.className = 'btn'; btnExport.textContent = 'Export';
  const btnPin = document.createElement('button'); btnPin.className = 'btn'; btnPin.textContent = 'Add to Desktop';

  header.append(titleEl, btnNew, btnSave, btnExport, btnPin);

  const ta = document.createElement('textarea');
  ta.style.flex = '1';
  ta.style.margin = '8px';
  ta.placeholder = 'Write notes...';

  let currentFileId = opts.fileId || null;
  let currentFile = opts.file || null;

  function updateTitle() {
    const name = currentFile ? (currentFile.name || 'Untitled.nt') : 'Untitled.nt';
    titleEl.textContent = `Notepad — ${name}`;
  }

  function loadFromFile(file, fileId) {
    currentFile = file || null;
    currentFileId = fileId || null;
    ta.value = (file && (file.text != null ? file.text : '')) || '';
    updateTitle();
  }

  // Initialize content
  if (currentFile) {
    loadFromFile(currentFile, currentFileId);
  } else {
    ta.value = '';
    updateTitle();
  }

  function ensureNtName(name) {
    name = (name || '').trim();
    if (!name) name = 'Untitled.nt';
    if (!name.toLowerCase().endsWith('.nt')) name += '.nt';
    return name;
  }

  function doSave() {
    if (!currentFileId) return doSaveAs();
    if (!state.files[currentFileId]) return doSaveAs();
    state.files[currentFileId].text = ta.value;
    // Keep other metadata (name, type)
    alert('Saved');
    return currentFileId;
  }

  function doSaveAs() {
    let name = prompt('Save note as:', currentFile && currentFile.name ? currentFile.name : 'Untitled.nt');
    if (name == null) return null; // cancel
    name = ensureNtName(name);
    const id = 'f' + Date.now().toString(36) + Math.random().toString(36).slice(2,4);
    state.files[id] = {
      name,
      type: 'text/rtos-note',
      text: ta.value,
      folder: 'root'
    };
    currentFileId = id;
    currentFile = state.files[id];
    updateTitle();
    alert('Saved as ' + name);
    return id;
  }

  btnNew.onclick = () => {
    ta.value = '';
    currentFile = null; currentFileId = null;
    updateTitle();
  };

  btnSave.onclick = () => { doSave(); };

  btnExport.onclick = () => {
    const blob = new Blob([ta.value], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (currentFile && currentFile.name ? currentFile.name.replace(/\.nt$/i, '.txt') : 'note.txt');
    a.click();
    URL.revokeObjectURL(a.href);
  };

  btnPin.onclick = () => {
    const id = currentFileId || doSaveAs();
    if (!id) return;
    state.desktopShortcuts = state.desktopShortcuts || [];
    if (!state.desktopShortcuts.includes(id)) state.desktopShortcuts.push(id);
    renderDesktopIcons();
    alert('Shortcut added to desktop');
  };

  // Enable desktop context menu inside Notes
  root.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    showContextMenu(e, null);
  });

  // Handle being asked to open a note into this window
  setTimeout(() => {
    const winEl = root.closest('.window');
    if (!winEl) return;
    winEl.addEventListener('rtos-open-note', (ev) => {
      const d = ev.detail || {};
      loadFromFile(d.file, d.fileId);
    });
  }, 0);

  root.append(header, ta);
  return root;
}

/* ----------------------
   Paint app
   ---------------------- */
function paintApp() {
  const root = document.createElement("div");
  root.className = "canvas-container";
  // Title removed to maximize drawing area
  
  const tools = document.createElement("div");
  tools.className = "canvas-tools";
  
  const colorPicker = document.createElement("input");
  colorPicker.type = "color";
  // Dark-only: default to white brush
  colorPicker.value = "#ffffff";
  colorPicker.className = "color-picker";
  
  const brushSize = document.createElement("input");
  brushSize.type = "range";
  brushSize.min = "1";
  brushSize.max = "50";
  brushSize.value = "5";
  brushSize.className = "brush-size";

  // No size controls — fixed canvas
  
  const clearBtn = document.createElement("button");
  clearBtn.className = "btn";
  clearBtn.textContent = "Clear";
  
  const undoBtn = document.createElement("div");
  undoBtn.className = "tool-btn";
  undoBtn.textContent = "↩️";
  undoBtn.title = "Undo";
  
  const eraserBtn = document.createElement("div");
  eraserBtn.className = "tool-btn";
  eraserBtn.textContent = "🧽";
  eraserBtn.title = "Eraser";
  
  const brushBtn = document.createElement("div");
  brushBtn.className = "tool-btn active";
  brushBtn.textContent = "🖌️";
  brushBtn.title = "Brush";
  
  const saveBtn = document.createElement("button");
  saveBtn.className = "btn";
  saveBtn.textContent = "Set as Wallpaper";
  
  tools.append(colorPicker, brushSize, brushBtn, eraserBtn, undoBtn, clearBtn, saveBtn);
  
  const canvasWrapper = document.createElement("div");
  canvasWrapper.className = "canvas-wrapper";
  
  const canvas = document.createElement("canvas");
  canvas.id = "paintCanvas";
  
  canvasWrapper.appendChild(canvas);
  root.append(tools, canvasWrapper);
  
  const ctx = canvas.getContext("2d");
  let dpr = Math.max(1, window.devicePixelRatio || 1);


  function resizeCanvas() {
    // Fixed size: 1920x1080, fit to wrapper
    const cssW = 1920, cssH = 1080;
    canvasWrapper.style.width = cssW + 'px';
    canvasWrapper.style.height = cssH + 'px';
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);

    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
    // Dark-only background
    ctx.fillStyle = "#1a1c20";
    ctx.fillRect(0, 0, cssW, cssH);
    ctx.lineCap = "round";
    ctx.strokeStyle = colorPicker.value;
    ctx.lineWidth = parseFloat(brushSize.value);
  }

  // Initial fixed size
  resizeCanvas();
  // No observers or controls — stays fixed

  let isDrawing = false;
  let lastX = 0;
  let lastY = 0;
  let drawingHistory = [];
  let currentTool = "brush";
  
  function saveDrawingState() {
    drawingHistory.push(canvas.toDataURL());
    if (drawingHistory.length > 20) {
      drawingHistory.shift();
    }
  }
  
  function startDrawing(e) {
    isDrawing = true;
    [lastX, lastY] = [e.offsetX, e.offsetY];
    saveDrawingState();
  }
  
  function draw(e) {
    if (!isDrawing) return;
    ctx.beginPath();
    ctx.moveTo(lastX, lastY);
    ctx.lineTo(e.offsetX, e.offsetY);
    ctx.stroke();
    [lastX, lastY] = [e.offsetX, e.offsetY];
  }
  
  function stopDrawing() {
    isDrawing = false;
  }
  
  canvas.addEventListener("mousedown", startDrawing);
  canvas.addEventListener("mousemove", draw);
  canvas.addEventListener("mouseup", stopDrawing);
  canvas.addEventListener("mouseout", stopDrawing);
  
  colorPicker.addEventListener("input", () => {
    ctx.strokeStyle = colorPicker.value;
  });
  
  brushSize.addEventListener("input", () => {
    ctx.lineWidth = brushSize.value;
  });
  
  clearBtn.addEventListener("click", () => {
    saveDrawingState();
    const rect = canvasWrapper.getBoundingClientRect();
    ctx.fillStyle = "#1a1c20";
    ctx.fillRect(0, 0, Math.floor(rect.width), Math.floor(rect.height));
  });
  
  undoBtn.addEventListener("click", () => {
    if (drawingHistory.length > 0) {
      const img = new Image();
      img.onload = function() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
        drawingHistory.pop();
      };
      img.src = drawingHistory.pop() || "";
    }
  });
  
  brushBtn.addEventListener("click", () => {
    currentTool = "brush";
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = colorPicker.value;
    brushBtn.classList.add("active");
    eraserBtn.classList.remove("active");
  });
  
  eraserBtn.addEventListener("click", () => {
    currentTool = "eraser";
    ctx.globalCompositeOperation = "destination-out";
    eraserBtn.classList.add("active");
    brushBtn.classList.remove("active");
  });
  
  saveBtn.addEventListener("click", () => {
    const dataURL = canvas.toDataURL("image/png");
    const id = "paint-" + Date.now();
    state.wallpapers[id] = `url("${dataURL}")`;
    state.settings.wallpaper = id;
    applyWallpaper();
    
    const fileId = 'f' + Date.now().toString(36);
    state.files[fileId] = {
      name: `paint-${new Date().toISOString().split('T')[0]}.png`,
      type: "image/png",
      dataURL: dataURL,
      folder: "root"
    };
    
    alert("Drawing set as wallpaper and saved to Files");
  });
  
  return root;
}

/* ----------------------
   Calculator / Clock
   ---------------------- */
function calcApp() {
  const root = document.createElement("div");
  root.style.display = "flex"; 
  root.style.flexDirection = "column"; 
  root.style.gap = "8px"; 
  
  const disp = document.createElement("input");
  disp.readOnly = true;
  disp.style.fontSize = "20px";
  disp.style.fontWeight = "700";
  disp.value = "";
  
  const buttons = [
    ["7","8","9","/"],
    ["4","5","6","*"],
    ["1","2","3","-"],
    ["0",".","=","+"]
  ];
  
  const grid = document.createElement("div"); 
  grid.style.display = "grid"; 
  grid.style.gridTemplateColumns = "repeat(4,1fr)"; 
  grid.style.gap = "8px";
  
  buttons.flat().forEach(ch => {
    const b = document.createElement("button"); 
    b.className = "btn"; 
    b.innerText = ch;
    b.onclick = () => {
      if (ch === "=") {
        try { 
          disp.value = eval(disp.value) || ""; 
        } catch(e) { 
          disp.value = "Error"; 
        }
      } else {
        disp.value += ch;
      }
    };
    grid.append(b);
  });
  
  root.append(disp, grid);
  return root;
}

function clockApp() {
  const root = document.createElement("div"); 
  root.style.display = "flex"; 
  root.style.flexDirection = "column"; 
  root.style.alignItems = "center"; 
  root.style.justifyContent = "center";
  
  const time = document.createElement("div"); 
  time.style.fontSize = "36px"; 
  time.style.fontWeight = "800";
  
  function tick() {
    const now = new Date();
    time.innerText = now.toLocaleTimeString();
  }
  
  tick(); 
  setInterval(tick, 1000);
  root.append(time);
  return root;
}

/* ----------------------
   CMD app: simple REPL
   ---------------------- */
function cmdApp() {
  const root = document.createElement("div"); 
  root.style.display = "flex"; 
  root.style.flexDirection = "column"; 
  root.style.height = "100%";
  
  const log = document.createElement("div"); 
  log.style.flex = "1"; 
  log.style.overflow = "auto"; 
  log.style.background = "#000"; 
  log.style.padding = "12px"; 
  log.style.borderRadius = "8px"; 
  log.style.fontFamily = "monospace"; 
  log.style.fontSize = "13px"; 
  // Switch to modern white on dark by default
  log.style.color = "#ffffff";
  // Preserve ASCII spacing for banners and formatted output
  log.style.whiteSpace = "pre";
  
  const inputWrap = document.createElement("div"); 
  inputWrap.style.display = "flex"; 
  inputWrap.style.gap = "8px"; 
  inputWrap.style.marginTop = "8px";
  
  const inp = document.createElement("input"); 
  inp.style.flex = "1"; 
  inp.style.fontFamily = "monospace"; 
  inp.placeholder = "Type a command (help)";
  
  const btn = document.createElement("button"); 
  btn.className = "btn"; 
  btn.innerText = "Run";
  
  inputWrap.append(inp, btn);
  root.append(log, inputWrap);

  // Utilities
  function write(line, cls) { 
    const d = document.createElement('div'); 
    if (cls) d.className = cls; 
    d.textContent = line; 
    log.appendChild(d); 
    log.scrollTop = log.scrollHeight; 
  }
  function writeStyled(line, style = "") {
    const d = document.createElement('div');
    d.textContent = line;
    if (style) d.setAttribute('style', style);
    log.appendChild(d);
    log.scrollTop = log.scrollHeight;
  }
  const getAccent = () => (getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#ffffff').trim() || '#ffffff';
  
  // History + focus
  const history = [];
  let hIndex = -1;

  write("RT CMD v1.0 - type 'help' for commands");
  write("-------------------------------------", "cmd-sep");

  // Matrix fun effect
  let matrixTimer = null;
  function startMatrix() {
    if (matrixTimer) return;
    const cols = Math.max(24, Math.floor(log.clientWidth / 10));
    matrixTimer = setInterval(() => {
      const line = Array.from({length: cols}, () => "01"[Math.floor(Math.random()*2)]).join('');
      writeStyled(line, 'color:#2efc9a; font-weight:600; letter-spacing:1px;');
      if (log.childElementCount > 400) log.removeChild(log.firstChild);
    }, 60);
  }
  function stopMatrix() { if (matrixTimer) { clearInterval(matrixTimer); matrixTimer = null; } }
 
  // Sandbox helpers for safe HTML execution
  function sandboxWindowFromHtml(html, title = "Mod (sandbox)") {
    const root = document.createElement('div');
    root.style.height = '100%';
    root.style.display = 'flex';
    const iframe = document.createElement('iframe');
    iframe.style.border = 'none';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.setAttribute('sandbox', 'allow-scripts allow-modals');
    iframe.srcdoc = html || '<!doctype html><title>Empty</title><body style="font-family:system-ui;color:#fff;background:#111;padding:16px">(empty)</body>';
    root.appendChild(iframe);
    createWindow(root, { title, id: 'mod-' + Date.now().toString(36) });
  }
 
  function sandboxWindowFromUrl(url, title = "Mod (sandbox)") {
    const root = document.createElement('div');
    root.style.height = '100%';
    root.style.display = 'flex';
    const iframe = document.createElement('iframe');
    iframe.style.border = 'none';
    iframe.style.width = '100%';
    iframe.style.height = '100%';
    iframe.setAttribute('sandbox', 'allow-scripts allow-modals');
    iframe.src = url;
    root.appendChild(iframe);
    createWindow(root, { title, id: 'mod-' + Date.now().toString(36) });
  }

  function runCmd(raw) {
    if (!raw) return;
    write("> " + raw, "cmd-in");
    const parts = raw.trim().split(/\s+/);
    const cmd = parts[0].toLowerCase();
    const args = parts.slice(1);
    // Aliases to make common variants work (e.g., 'IS' vs 'ls')
    const aliasMap = {
      'is': 'ls',
      'dir': 'ls',
      'type': 'cat',
      'quit': 'exit'
    };
    const resolved = aliasMap[cmd] || cmd;
    
    if (resolved === 'help') {
      write("Available commands:");
      write("  help            - Show this help");
      write("  clear | cls     - Clear the screen");
      write("  date            - Show current date and time");
      write("  echo [text]     - Echo the provided text");
      write("  ls              - List files");
      write("  cat [file]      - Show file contents");
      write("  open [app]      - Open an application");
      write("  sysinfo         - Show system info");
      write("  rand [n]        - Random 0..n (default 100)");
      write("  color [c]       - Set text color (white|accent|#hex|green)");
      write("  matrix on/off   - Toggle matrix rain");
      write("  banner          - Show RT ASCII banner");
      write("  whoami          - Current user");
      write("  uptime          - Time since boot");
      write("  ping [host]     - Ping a host");
      write("  load-url [url]  - Open external HTML in sandboxed window");
      write("  inject-html     - Paste HTML to run in sandboxed window");
      write("  run-file [name] - Run saved file as sandboxed HTML");
      write("  erase-all       - Erase ALL accounts and saved data");
      write("  erase-account <name> - Remove a single account and its data");
      write("  shutdown        - Show shutdown screen");
      write("  restart|reboot  - Restart RT OS");
      write("  exit            - Close this CMD window");
      write("-------------------------------------", "cmd-sep");
    } 
    else if (resolved === 'date') {
      write(new Date().toString());
    } 
    else if (resolved === 'clear' || resolved === 'cls') {
      log.innerHTML = "";
      write("RT CMD v1.0 - type 'help' for commands");
      write("-------------------------------------", "cmd-sep");
    } 
    else if (resolved === 'echo') {
      write(args.join(' '));
    } 
    else if (resolved === 'ls') {
      const files = Object.entries(state.files || {}).map(([id, f]) => f.name);
      if (files.length === 0) write("(no files)");
      else files.forEach(fn => write(fn));
    } 
    else if (resolved === 'cat') {
      const name = args.join(' ');
      if (!name) { write("Usage: cat <filename>"); return; }
      const entry = Object.values(state.files || {}).find(f => f.name === name);
      if (!entry) { write("File not found: " + name); return; }
      if (entry.type && entry.type.startsWith('image/')) { write("[binary image data]"); }
      else { write(entry.text || "[no text available]"); }
    }
    else if (resolved === 'open') {
      const app = args[0];
      if (!app) { write("Usage: open [app]"); return; }
      if (app in state.installedApps) {
        openApp(app);
        write(`Opening ${state.installedApps[app].name}...`);
      } else {
        write(`Application '${app}' not found. Available apps: ${Object.keys(state.installedApps).join(', ')}`);
      }
    }
    else if (resolved === 'sysinfo') {
      const appsOpen = Object.keys(state.openWindows || {}).length;
      const res = `${window.innerWidth}x${window.innerHeight}@${Math.round((window.devicePixelRatio||1)*100)/100}x`;
      write(`User: ${getCurrentUsername()}`);
      write(`Windows open: ${appsOpen}`);
      write(`Resolution: ${res}`);
      write(`Accent: ${state.settings?.accent || 'system'} (${state.settings?.accentColor || getAccent()})`);
    }
    else if (resolved === 'rand') {
      const max = Math.max(1, parseInt(args[0]||'100', 10) || 100);
      write(String(Math.floor(Math.random()*(max+1))));
    }
    else if (resolved === 'color') {
      const c = (args[0]||'').toLowerCase();
      if (!c) { write(`Current color: ${log.style.color}`); return; }
      if (c === 'white') log.style.color = '#ffffff';
      else if (c === 'green') log.style.color = '#6efc6e';
      else if (c === 'accent') log.style.color = getAccent();
      else if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(c)) log.style.color = c;
      else write("Unknown color. Try white | accent | #hex | green");
    }
    else if (resolved === 'matrix') {
      const mode = (args[0]||'').toLowerCase();
      if (mode === 'on' || mode === 'start') { startMatrix(); write("Matrix started"); }
      else if (mode === 'off' || mode === 'stop') { stopMatrix(); write("Matrix stopped"); }
      else write("Usage: matrix on|off");
    }
    else if (resolved === 'banner') {
      const lines = [
        "██████╗ ████████╗",
        "██╔══██╗╚══██╔══╝",
        "██████╔╝   ██║",
        "██╔══██╗   ██║",
        "██║  ██║   ██║",
        "╚═╝  ╚═╝   ╚═╝",
        "RT OS LOGO"
      ];
      lines.forEach(l => writeStyled(l, `color:${getAccent()}; font-weight:800;`));
    }
    else if (resolved === 'whoami') {
      write(getCurrentUsername());
    }
    else if (resolved === 'uptime') {
      const secs = Math.floor(performance.now() / 1000);
      const h = Math.floor(secs/3600), m = Math.floor((secs%3600)/60), s = secs%60;
      write(`${h}h ${m}m ${s}s`);
    }
    else if (resolved === 'ping') {
      const host = args[0] || 'localhost';
      const ms = Math.floor(10 + Math.random()*120);
      write(`Pinging ${host} with 32 bytes of data:`);
      for (let i = 0; i < 4; i++) {
        write(`Reply from ${host}: bytes=32 time=${ms + i}ms TTL=58`);
      }
      write(`Ping statistics for ${host}: Packets: Sent = 4, Received = 4, Lost = 0 (0% loss)`);
      write(`Approximate round trip times in milli-seconds: Minimum = ${ms}ms, Maximum = ${ms+3}ms, Average = ${ms+1}ms`);
    }
    else if (resolved === 'load-url') {
      let url = args.join(' ');
      if (!url) { write("Usage: load-url <url>"); return; }
      if (!/^https?:\/\//i.test(url)) url = 'https://' + url;
      write(`Opening ${url} in sandboxed window...`);
      sandboxWindowFromUrl(url, `Sandbox: ${url}`);
    }
    else if (resolved === 'inject-html') {
      const html = prompt('Paste HTML to run in sandboxed window:');
      if (!html) { write('(cancelled)'); return; }
      write('Launching sandboxed HTML...');
      sandboxWindowFromHtml(html, 'Sandbox: Custom HTML');
    }
    else if (resolved === 'erase-all') {
      if (confirm('Erase ALL RT OS data (accounts and saved state)?')) {
        try { wipeAllData(); } catch(_) {}
        write('All data erased. Restarting...');
        setTimeout(() => location.reload(), 200);
      } else {
        write('Cancelled.');
      }
    }
    else if (resolved === 'erase-account') {
      const name = args.join(' ') || prompt('Enter account name to erase:');
      if (!name) { write('No account name provided.'); return; }
      const res = wipeAccountByName(name);
      if (!res.ok) { write(res.msg || 'Failed to erase account'); return; }
      write(`Erased account: ${name}`);
      setTimeout(() => location.reload(), 200);
    }
    else if (resolved === 'run-file') {
      const name = args.join(' ');
      if (!name) { write("Usage: run-file <filename>"); return; }
      const entry = Object.values(state.files || {}).find(f => f.name === name);
      if (!entry) { write("File not found: " + name); return; }
      const html = entry.text || '';
      if (!html) { write("Selected file has no text content to run as HTML."); return; }
      write(`Running '${name}' in sandbox...`);
      sandboxWindowFromHtml(html, `Sandbox: ${name}`);
    }
    else if (resolved === 'shutdown') {
      write('Shutting down...');
      // Use unified shutdown overlay + chime
      if (typeof playShutdownAndExit === 'function') {
        playShutdownAndExit();
      }
      // Close windows shortly after to simulate app termination
      setTimeout(() => {
        document.querySelectorAll('.window').forEach(w => w.remove());
      }, 300);
    }
    else if (resolved === 'restart') {
      write('Restarting…');
      playRestartSequence();
    }
    else if (resolved === 'reboot') {
      write('Rebooting...');
      const boot = document.getElementById('boot');
      if (boot) {
        boot.classList.remove('hidden');
        const sub = boot.querySelector('.boot-sub');
        if (sub) sub.textContent = 'Rebooting...';
      }
      setTimeout(() => location.reload(), 800);
    }
    else if (resolved === 'exit') {
      const win = root.closest('.window');
      if (win) {
        // Prefer the standard close routine (anim + taskbar cleanup)
        const closeBtn = win.querySelector('.controls .wbtn:last-child');
        if (closeBtn) closeBtn.dispatchEvent(new MouseEvent('click', { bubbles: true }));
        else {
          // Fallback: ensure taskbar icon and state are cleaned
          const appId = win.dataset.appId;
          try { if (appId && typeof removeTaskIcon === 'function') removeTaskIcon(appId); } catch(_) {}
          if (appId && state.openWindows) delete state.openWindows[appId];
          win.remove();
        }
      }
    }
    else {
      write("Unknown command: " + cmd);
      write("Type 'help' for available commands");
    }
  }

  btn.onclick = () => { 
    if (inp.value.trim()) { history.unshift(inp.value.trim()); hIndex = -1; }
    runCmd(inp.value); 
    inp.value = ""; 
    inp.focus(); 
  };
  
  inp.addEventListener("keydown", (e) => { 
    if (e.key === 'Enter') { 
      if (inp.value.trim()) { history.unshift(inp.value.trim()); hIndex = -1; }
      runCmd(inp.value); 
      inp.value = ""; 
    } else if (e.key === 'ArrowUp') {
      if (history.length) {
        hIndex = Math.min(hIndex + 1, history.length - 1);
        inp.value = history[hIndex];
        setTimeout(() => inp.setSelectionRange(inp.value.length, inp.value.length), 0);
      }
      e.preventDefault();
    } else if (e.key === 'ArrowDown') {
      if (history.length) {
        hIndex = Math.max(hIndex - 1, -1);
        inp.value = hIndex === -1 ? '' : history[hIndex];
        setTimeout(() => inp.setSelectionRange(inp.value.length, inp.value.length), 0);
      }
      e.preventDefault();
    }
  });
  
  return root;
}

/* Installation flow removed: starting directly at boot */

/* Expose a quick debug API in console for dev */
window._rtos = { state, createWindow, openApp };
</script>
</body>
</html>